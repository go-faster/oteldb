// Code generated by ogen, DO NOT EDIT.

package otelschema

import (
	"fmt"
	"math/bits"
	"strconv"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"

	"github.com/ogen-go/ogen/validate"
)

// Ref: #/$defs/attribute
type Attribute struct {
	ID               string              `json:"id"`
	SamplingRelevant OptBool             `json:"sampling_relevant"`
	Type             AttributeType       `json:"type"`
	Brief            OptString           `json:"brief"`
	Note             OptString           `json:"note"`
	Tag              OptString           `json:"tag"`
	Examples         jx.Raw              `json:"examples"`
	RequirementLevel OptRequirementLevel `json:"requirement_level"`
	Stability        OptString           `json:"stability"`
}

// GetID returns the value of ID.
func (s *Attribute) GetID() string {
	return s.ID
}

// GetSamplingRelevant returns the value of SamplingRelevant.
func (s *Attribute) GetSamplingRelevant() OptBool {
	return s.SamplingRelevant
}

// GetType returns the value of Type.
func (s *Attribute) GetType() AttributeType {
	return s.Type
}

// GetBrief returns the value of Brief.
func (s *Attribute) GetBrief() OptString {
	return s.Brief
}

// GetNote returns the value of Note.
func (s *Attribute) GetNote() OptString {
	return s.Note
}

// GetTag returns the value of Tag.
func (s *Attribute) GetTag() OptString {
	return s.Tag
}

// GetExamples returns the value of Examples.
func (s *Attribute) GetExamples() jx.Raw {
	return s.Examples
}

// GetRequirementLevel returns the value of RequirementLevel.
func (s *Attribute) GetRequirementLevel() OptRequirementLevel {
	return s.RequirementLevel
}

// GetStability returns the value of Stability.
func (s *Attribute) GetStability() OptString {
	return s.Stability
}

// SetID sets the value of ID.
func (s *Attribute) SetID(val string) {
	s.ID = val
}

// SetSamplingRelevant sets the value of SamplingRelevant.
func (s *Attribute) SetSamplingRelevant(val OptBool) {
	s.SamplingRelevant = val
}

// SetType sets the value of Type.
func (s *Attribute) SetType(val AttributeType) {
	s.Type = val
}

// SetBrief sets the value of Brief.
func (s *Attribute) SetBrief(val OptString) {
	s.Brief = val
}

// SetNote sets the value of Note.
func (s *Attribute) SetNote(val OptString) {
	s.Note = val
}

// SetTag sets the value of Tag.
func (s *Attribute) SetTag(val OptString) {
	s.Tag = val
}

// SetExamples sets the value of Examples.
func (s *Attribute) SetExamples(val jx.Raw) {
	s.Examples = val
}

// SetRequirementLevel sets the value of RequirementLevel.
func (s *Attribute) SetRequirementLevel(val OptRequirementLevel) {
	s.RequirementLevel = val
}

// SetStability sets the value of Stability.
func (s *Attribute) SetStability(val OptString) {
	s.Stability = val
}

// Ref: #/$defs/attributeReference
type AttributeReference struct {
	Ref              string              `json:"ref"`
	Brief            OptString           `json:"brief"`
	Note             OptString           `json:"note"`
	Tag              OptString           `json:"tag"`
	Examples         []jx.Raw            `json:"examples"`
	RequirementLevel OptRequirementLevel `json:"requirement_level"`
	SamplingRelevant OptBool             `json:"sampling_relevant"`
}

// GetRef returns the value of Ref.
func (s *AttributeReference) GetRef() string {
	return s.Ref
}

// GetBrief returns the value of Brief.
func (s *AttributeReference) GetBrief() OptString {
	return s.Brief
}

// GetNote returns the value of Note.
func (s *AttributeReference) GetNote() OptString {
	return s.Note
}

// GetTag returns the value of Tag.
func (s *AttributeReference) GetTag() OptString {
	return s.Tag
}

// GetExamples returns the value of Examples.
func (s *AttributeReference) GetExamples() []jx.Raw {
	return s.Examples
}

// GetRequirementLevel returns the value of RequirementLevel.
func (s *AttributeReference) GetRequirementLevel() OptRequirementLevel {
	return s.RequirementLevel
}

// GetSamplingRelevant returns the value of SamplingRelevant.
func (s *AttributeReference) GetSamplingRelevant() OptBool {
	return s.SamplingRelevant
}

// SetRef sets the value of Ref.
func (s *AttributeReference) SetRef(val string) {
	s.Ref = val
}

// SetBrief sets the value of Brief.
func (s *AttributeReference) SetBrief(val OptString) {
	s.Brief = val
}

// SetNote sets the value of Note.
func (s *AttributeReference) SetNote(val OptString) {
	s.Note = val
}

// SetTag sets the value of Tag.
func (s *AttributeReference) SetTag(val OptString) {
	s.Tag = val
}

// SetExamples sets the value of Examples.
func (s *AttributeReference) SetExamples(val []jx.Raw) {
	s.Examples = val
}

// SetRequirementLevel sets the value of RequirementLevel.
func (s *AttributeReference) SetRequirementLevel(val OptRequirementLevel) {
	s.RequirementLevel = val
}

// SetSamplingRelevant sets the value of SamplingRelevant.
func (s *AttributeReference) SetSamplingRelevant(val OptBool) {
	s.SamplingRelevant = val
}

// AttributeType represents sum type.
type AttributeType struct {
	Type   AttributeTypeType // switch on this field
	Enum   Enum
	String string
}

// AttributeTypeType is oneOf type of AttributeType.
type AttributeTypeType string

// Possible values for AttributeTypeType.
const (
	EnumAttributeType   AttributeTypeType = "Enum"
	StringAttributeType AttributeTypeType = "string"
)

// IsEnum reports whether AttributeType is Enum.
func (s AttributeType) IsEnum() bool { return s.Type == EnumAttributeType }

// IsString reports whether AttributeType is string.
func (s AttributeType) IsString() bool { return s.Type == StringAttributeType }

// SetEnum sets AttributeType to Enum.
func (s *AttributeType) SetEnum(v Enum) {
	s.Type = EnumAttributeType
	s.Enum = v
}

// GetEnum returns Enum and true boolean if AttributeType is Enum.
func (s AttributeType) GetEnum() (v Enum, ok bool) {
	if !s.IsEnum() {
		return v, false
	}
	return s.Enum, true
}

// NewEnumAttributeType returns new AttributeType from Enum.
func NewEnumAttributeType(v Enum) AttributeType {
	var s AttributeType
	s.SetEnum(v)
	return s
}

// SetString sets AttributeType to string.
func (s *AttributeType) SetString(v string) {
	s.Type = StringAttributeType
	s.String = v
}

// GetString returns string and true boolean if AttributeType is string.
func (s AttributeType) GetString() (v string, ok bool) {
	if !s.IsString() {
		return v, false
	}
	return s.String, true
}

// NewStringAttributeType returns new AttributeType from string.
func NewStringAttributeType(v string) AttributeType {
	var s AttributeType
	s.SetString(v)
	return s
}

// Ref: #/$defs/enum
type Enum struct {
	AllowCustomValues OptBool           `json:"allow_custom_values"`
	Members           []EnumMembersItem `json:"members"`
}

// GetAllowCustomValues returns the value of AllowCustomValues.
func (s *Enum) GetAllowCustomValues() OptBool {
	return s.AllowCustomValues
}

// GetMembers returns the value of Members.
func (s *Enum) GetMembers() []EnumMembersItem {
	return s.Members
}

// SetAllowCustomValues sets the value of AllowCustomValues.
func (s *Enum) SetAllowCustomValues(val OptBool) {
	s.AllowCustomValues = val
}

// SetMembers sets the value of Members.
func (s *Enum) SetMembers(val []EnumMembersItem) {
	s.Members = val
}

type EnumMembersItem struct {
	ID    string               `json:"id"`
	Note  OptString            `json:"note"`
	Value EnumMembersItemValue `json:"value"`
	Brief OptString            `json:"brief"`
}

// GetID returns the value of ID.
func (s *EnumMembersItem) GetID() string {
	return s.ID
}

// GetNote returns the value of Note.
func (s *EnumMembersItem) GetNote() OptString {
	return s.Note
}

// GetValue returns the value of Value.
func (s *EnumMembersItem) GetValue() EnumMembersItemValue {
	return s.Value
}

// GetBrief returns the value of Brief.
func (s *EnumMembersItem) GetBrief() OptString {
	return s.Brief
}

// SetID sets the value of ID.
func (s *EnumMembersItem) SetID(val string) {
	s.ID = val
}

// SetNote sets the value of Note.
func (s *EnumMembersItem) SetNote(val OptString) {
	s.Note = val
}

// SetValue sets the value of Value.
func (s *EnumMembersItem) SetValue(val EnumMembersItemValue) {
	s.Value = val
}

// SetBrief sets the value of Brief.
func (s *EnumMembersItem) SetBrief(val OptString) {
	s.Brief = val
}

// EnumMembersItemValue represents sum type.
type EnumMembersItemValue struct {
	Type    EnumMembersItemValueType // switch on this field
	String  string
	Float64 float64
}

// EnumMembersItemValueType is oneOf type of EnumMembersItemValue.
type EnumMembersItemValueType string

// Possible values for EnumMembersItemValueType.
const (
	StringEnumMembersItemValue  EnumMembersItemValueType = "string"
	Float64EnumMembersItemValue EnumMembersItemValueType = "float64"
)

// IsString reports whether EnumMembersItemValue is string.
func (s EnumMembersItemValue) IsString() bool { return s.Type == StringEnumMembersItemValue }

// IsFloat64 reports whether EnumMembersItemValue is float64.
func (s EnumMembersItemValue) IsFloat64() bool { return s.Type == Float64EnumMembersItemValue }

// SetString sets EnumMembersItemValue to string.
func (s *EnumMembersItemValue) SetString(v string) {
	s.Type = StringEnumMembersItemValue
	s.String = v
}

// GetString returns string and true boolean if EnumMembersItemValue is string.
func (s EnumMembersItemValue) GetString() (v string, ok bool) {
	if !s.IsString() {
		return v, false
	}
	return s.String, true
}

// NewStringEnumMembersItemValue returns new EnumMembersItemValue from string.
func NewStringEnumMembersItemValue(v string) EnumMembersItemValue {
	var s EnumMembersItemValue
	s.SetString(v)
	return s
}

// SetFloat64 sets EnumMembersItemValue to float64.
func (s *EnumMembersItemValue) SetFloat64(v float64) {
	s.Type = Float64EnumMembersItemValue
	s.Float64 = v
}

// GetFloat64 returns float64 and true boolean if EnumMembersItemValue is float64.
func (s EnumMembersItemValue) GetFloat64() (v float64, ok bool) {
	if !s.IsFloat64() {
		return v, false
	}
	return s.Float64, true
}

// NewFloat64EnumMembersItemValue returns new EnumMembersItemValue from float64.
func NewFloat64EnumMembersItemValue(v float64) EnumMembersItemValue {
	var s EnumMembersItemValue
	s.SetFloat64(v)
	return s
}

// NewOptBool returns new OptBool with value set to v.
func NewOptBool(v bool) OptBool {
	return OptBool{
		Value: v,
		Set:   true,
	}
}

// OptBool is optional bool.
type OptBool struct {
	Value bool
	Set   bool
}

// IsSet returns true if OptBool was set.
func (o OptBool) IsSet() bool { return o.Set }

// Reset unsets value.
func (o *OptBool) Reset() {
	var v bool
	o.Value = v
	o.Set = false
}

// SetTo sets value to v.
func (o *OptBool) SetTo(v bool) {
	o.Set = true
	o.Value = v
}

// Get returns value and boolean that denotes whether value was set.
func (o OptBool) Get() (v bool, ok bool) {
	if !o.Set {
		return v, false
	}
	return o.Value, true
}

// Or returns value if set, or given parameter if does not.
func (o OptBool) Or(d bool) bool {
	if v, ok := o.Get(); ok {
		return v
	}
	return d
}

// NewOptRequirementLevel returns new OptRequirementLevel with value set to v.
func NewOptRequirementLevel(v RequirementLevel) OptRequirementLevel {
	return OptRequirementLevel{
		Value: v,
		Set:   true,
	}
}

// OptRequirementLevel is optional RequirementLevel.
type OptRequirementLevel struct {
	Value RequirementLevel
	Set   bool
}

// IsSet returns true if OptRequirementLevel was set.
func (o OptRequirementLevel) IsSet() bool { return o.Set }

// Reset unsets value.
func (o *OptRequirementLevel) Reset() {
	var v RequirementLevel
	o.Value = v
	o.Set = false
}

// SetTo sets value to v.
func (o *OptRequirementLevel) SetTo(v RequirementLevel) {
	o.Set = true
	o.Value = v
}

// Get returns value and boolean that denotes whether value was set.
func (o OptRequirementLevel) Get() (v RequirementLevel, ok bool) {
	if !o.Set {
		return v, false
	}
	return o.Value, true
}

// Or returns value if set, or given parameter if does not.
func (o OptRequirementLevel) Or(d RequirementLevel) RequirementLevel {
	if v, ok := o.Get(); ok {
		return v
	}
	return d
}

// NewOptString returns new OptString with value set to v.
func NewOptString(v string) OptString {
	return OptString{
		Value: v,
		Set:   true,
	}
}

// OptString is optional string.
type OptString struct {
	Value string
	Set   bool
}

// IsSet returns true if OptString was set.
func (o OptString) IsSet() bool { return o.Set }

// Reset unsets value.
func (o *OptString) Reset() {
	var v string
	o.Value = v
	o.Set = false
}

// SetTo sets value to v.
func (o *OptString) SetTo(v string) {
	o.Set = true
	o.Value = v
}

// Get returns value and boolean that denotes whether value was set.
func (o OptString) Get() (v string, ok bool) {
	if !o.Set {
		return v, false
	}
	return o.Value, true
}

// Or returns value if set, or given parameter if does not.
func (o OptString) Or(d string) string {
	if v, ok := o.Get(); ok {
		return v
	}
	return d
}

// Ref: #/$defs/requirementLevel
// RequirementLevel represents sum type.
type RequirementLevel struct {
	Type              RequirementLevelType // switch on this field
	String            string
	RequirementLevel1 RequirementLevel1
}

// RequirementLevelType is oneOf type of RequirementLevel.
type RequirementLevelType string

// Possible values for RequirementLevelType.
const (
	StringRequirementLevel            RequirementLevelType = "string"
	RequirementLevel1RequirementLevel RequirementLevelType = "RequirementLevel1"
)

// IsString reports whether RequirementLevel is string.
func (s RequirementLevel) IsString() bool { return s.Type == StringRequirementLevel }

// IsRequirementLevel1 reports whether RequirementLevel is RequirementLevel1.
func (s RequirementLevel) IsRequirementLevel1() bool {
	return s.Type == RequirementLevel1RequirementLevel
}

// SetString sets RequirementLevel to string.
func (s *RequirementLevel) SetString(v string) {
	s.Type = StringRequirementLevel
	s.String = v
}

// GetString returns string and true boolean if RequirementLevel is string.
func (s RequirementLevel) GetString() (v string, ok bool) {
	if !s.IsString() {
		return v, false
	}
	return s.String, true
}

// NewStringRequirementLevel returns new RequirementLevel from string.
func NewStringRequirementLevel(v string) RequirementLevel {
	var s RequirementLevel
	s.SetString(v)
	return s
}

// SetRequirementLevel1 sets RequirementLevel to RequirementLevel1.
func (s *RequirementLevel) SetRequirementLevel1(v RequirementLevel1) {
	s.Type = RequirementLevel1RequirementLevel
	s.RequirementLevel1 = v
}

// GetRequirementLevel1 returns RequirementLevel1 and true boolean if RequirementLevel is RequirementLevel1.
func (s RequirementLevel) GetRequirementLevel1() (v RequirementLevel1, ok bool) {
	if !s.IsRequirementLevel1() {
		return v, false
	}
	return s.RequirementLevel1, true
}

// NewRequirementLevel1RequirementLevel returns new RequirementLevel from RequirementLevel1.
func NewRequirementLevel1RequirementLevel(v RequirementLevel1) RequirementLevel {
	var s RequirementLevel
	s.SetRequirementLevel1(v)
	return s
}

type RequirementLevel1 map[string]string

func (s *RequirementLevel1) init() RequirementLevel1 {
	m := *s
	if m == nil {
		m = map[string]string{}
		*s = m
	}
	return m
}

type Type struct {
	Groups []TypeGroupsItem `json:"groups"`
}

// GetGroups returns the value of Groups.
func (s *Type) GetGroups() []TypeGroupsItem {
	return s.Groups
}

// SetGroups sets the value of Groups.
func (s *Type) SetGroups(val []TypeGroupsItem) {
	s.Groups = val
}

type TypeGroupsItem struct {
	ID         string                         `json:"id"`
	Prefix     OptString                      `json:"prefix"`
	Type       OptString                      `json:"type"`
	Brief      OptString                      `json:"brief"`
	Note       OptString                      `json:"note"`
	Attributes []TypeGroupsItemAttributesItem `json:"attributes"`
}

// GetID returns the value of ID.
func (s *TypeGroupsItem) GetID() string {
	return s.ID
}

// GetPrefix returns the value of Prefix.
func (s *TypeGroupsItem) GetPrefix() OptString {
	return s.Prefix
}

// GetType returns the value of Type.
func (s *TypeGroupsItem) GetType() OptString {
	return s.Type
}

// GetBrief returns the value of Brief.
func (s *TypeGroupsItem) GetBrief() OptString {
	return s.Brief
}

// GetNote returns the value of Note.
func (s *TypeGroupsItem) GetNote() OptString {
	return s.Note
}

// GetAttributes returns the value of Attributes.
func (s *TypeGroupsItem) GetAttributes() []TypeGroupsItemAttributesItem {
	return s.Attributes
}

// SetID sets the value of ID.
func (s *TypeGroupsItem) SetID(val string) {
	s.ID = val
}

// SetPrefix sets the value of Prefix.
func (s *TypeGroupsItem) SetPrefix(val OptString) {
	s.Prefix = val
}

// SetType sets the value of Type.
func (s *TypeGroupsItem) SetType(val OptString) {
	s.Type = val
}

// SetBrief sets the value of Brief.
func (s *TypeGroupsItem) SetBrief(val OptString) {
	s.Brief = val
}

// SetNote sets the value of Note.
func (s *TypeGroupsItem) SetNote(val OptString) {
	s.Note = val
}

// SetAttributes sets the value of Attributes.
func (s *TypeGroupsItem) SetAttributes(val []TypeGroupsItemAttributesItem) {
	s.Attributes = val
}

// TypeGroupsItemAttributesItem represents sum type.
type TypeGroupsItemAttributesItem struct {
	Type               TypeGroupsItemAttributesItemType // switch on this field
	AttributeReference AttributeReference
	Attribute          Attribute
}

// TypeGroupsItemAttributesItemType is oneOf type of TypeGroupsItemAttributesItem.
type TypeGroupsItemAttributesItemType string

// Possible values for TypeGroupsItemAttributesItemType.
const (
	AttributeReferenceTypeGroupsItemAttributesItem TypeGroupsItemAttributesItemType = "AttributeReference"
	AttributeTypeGroupsItemAttributesItem          TypeGroupsItemAttributesItemType = "Attribute"
)

// IsAttributeReference reports whether TypeGroupsItemAttributesItem is AttributeReference.
func (s TypeGroupsItemAttributesItem) IsAttributeReference() bool {
	return s.Type == AttributeReferenceTypeGroupsItemAttributesItem
}

// IsAttribute reports whether TypeGroupsItemAttributesItem is Attribute.
func (s TypeGroupsItemAttributesItem) IsAttribute() bool {
	return s.Type == AttributeTypeGroupsItemAttributesItem
}

// SetAttributeReference sets TypeGroupsItemAttributesItem to AttributeReference.
func (s *TypeGroupsItemAttributesItem) SetAttributeReference(v AttributeReference) {
	s.Type = AttributeReferenceTypeGroupsItemAttributesItem
	s.AttributeReference = v
}

// GetAttributeReference returns AttributeReference and true boolean if TypeGroupsItemAttributesItem is AttributeReference.
func (s TypeGroupsItemAttributesItem) GetAttributeReference() (v AttributeReference, ok bool) {
	if !s.IsAttributeReference() {
		return v, false
	}
	return s.AttributeReference, true
}

// NewAttributeReferenceTypeGroupsItemAttributesItem returns new TypeGroupsItemAttributesItem from AttributeReference.
func NewAttributeReferenceTypeGroupsItemAttributesItem(v AttributeReference) TypeGroupsItemAttributesItem {
	var s TypeGroupsItemAttributesItem
	s.SetAttributeReference(v)
	return s
}

// SetAttribute sets TypeGroupsItemAttributesItem to Attribute.
func (s *TypeGroupsItemAttributesItem) SetAttribute(v Attribute) {
	s.Type = AttributeTypeGroupsItemAttributesItem
	s.Attribute = v
}

// GetAttribute returns Attribute and true boolean if TypeGroupsItemAttributesItem is Attribute.
func (s TypeGroupsItemAttributesItem) GetAttribute() (v Attribute, ok bool) {
	if !s.IsAttribute() {
		return v, false
	}
	return s.Attribute, true
}

// NewAttributeTypeGroupsItemAttributesItem returns new TypeGroupsItemAttributesItem from Attribute.
func NewAttributeTypeGroupsItemAttributesItem(v Attribute) TypeGroupsItemAttributesItem {
	var s TypeGroupsItemAttributesItem
	s.SetAttribute(v)
	return s
}

// Encode implements json.Marshaler.
func (s *Attribute) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Attribute) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.SamplingRelevant.Set {
			e.FieldStart("sampling_relevant")
			s.SamplingRelevant.Encode(e)
		}
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		if s.Brief.Set {
			e.FieldStart("brief")
			s.Brief.Encode(e)
		}
	}
	{
		if s.Note.Set {
			e.FieldStart("note")
			s.Note.Encode(e)
		}
	}
	{
		if s.Tag.Set {
			e.FieldStart("tag")
			s.Tag.Encode(e)
		}
	}
	{
		if len(s.Examples) != 0 {
			e.FieldStart("examples")
			e.Raw(s.Examples)
		}
	}
	{
		if s.RequirementLevel.Set {
			e.FieldStart("requirement_level")
			s.RequirementLevel.Encode(e)
		}
	}
	{
		if s.Stability.Set {
			e.FieldStart("stability")
			s.Stability.Encode(e)
		}
	}
}

var jsonFieldsNameOfAttribute = [9]string{
	0: "id",
	1: "sampling_relevant",
	2: "type",
	3: "brief",
	4: "note",
	5: "tag",
	6: "examples",
	7: "requirement_level",
	8: "stability",
}

// Decode decodes Attribute from json.
func (s *Attribute) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Attribute to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "sampling_relevant":
			if err := func() error {
				s.SamplingRelevant.Reset()
				if err := s.SamplingRelevant.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sampling_relevant\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "brief":
			if err := func() error {
				s.Brief.Reset()
				if err := s.Brief.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"brief\"")
			}
		case "note":
			if err := func() error {
				s.Note.Reset()
				if err := s.Note.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"note\"")
			}
		case "tag":
			if err := func() error {
				s.Tag.Reset()
				if err := s.Tag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "examples":
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.Examples = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"examples\"")
			}
		case "requirement_level":
			if err := func() error {
				s.RequirementLevel.Reset()
				if err := s.RequirementLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requirement_level\"")
			}
		case "stability":
			if err := func() error {
				s.Stability.Reset()
				if err := s.Stability.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stability\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Attribute")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000101,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAttribute) {
					name = jsonFieldsNameOfAttribute[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Attribute) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Attribute) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AttributeReference) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AttributeReference) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("ref")
		e.Str(s.Ref)
	}
	{
		if s.Brief.Set {
			e.FieldStart("brief")
			s.Brief.Encode(e)
		}
	}
	{
		if s.Note.Set {
			e.FieldStart("note")
			s.Note.Encode(e)
		}
	}
	{
		if s.Tag.Set {
			e.FieldStart("tag")
			s.Tag.Encode(e)
		}
	}
	{
		if s.Examples != nil {
			e.FieldStart("examples")
			e.ArrStart()
			for _, elem := range s.Examples {
				if len(elem) != 0 {
					e.Raw(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.RequirementLevel.Set {
			e.FieldStart("requirement_level")
			s.RequirementLevel.Encode(e)
		}
	}
	{
		if s.SamplingRelevant.Set {
			e.FieldStart("sampling_relevant")
			s.SamplingRelevant.Encode(e)
		}
	}
}

var jsonFieldsNameOfAttributeReference = [7]string{
	0: "ref",
	1: "brief",
	2: "note",
	3: "tag",
	4: "examples",
	5: "requirement_level",
	6: "sampling_relevant",
}

// Decode decodes AttributeReference from json.
func (s *AttributeReference) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AttributeReference to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ref":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Ref = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ref\"")
			}
		case "brief":
			if err := func() error {
				s.Brief.Reset()
				if err := s.Brief.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"brief\"")
			}
		case "note":
			if err := func() error {
				s.Note.Reset()
				if err := s.Note.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"note\"")
			}
		case "tag":
			if err := func() error {
				s.Tag.Reset()
				if err := s.Tag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "examples":
			if err := func() error {
				s.Examples = make([]jx.Raw, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem jx.Raw
					v, err := d.RawAppend(nil)
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					s.Examples = append(s.Examples, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"examples\"")
			}
		case "requirement_level":
			if err := func() error {
				s.RequirementLevel.Reset()
				if err := s.RequirementLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requirement_level\"")
			}
		case "sampling_relevant":
			if err := func() error {
				s.SamplingRelevant.Reset()
				if err := s.SamplingRelevant.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sampling_relevant\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AttributeReference")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAttributeReference) {
					name = jsonFieldsNameOfAttributeReference[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AttributeReference) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AttributeReference) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AttributeType as json.
func (s AttributeType) Encode(e *jx.Encoder) {
	switch s.Type {
	case EnumAttributeType:
		s.Enum.Encode(e)
	case StringAttributeType:
		e.Str(s.String)
	}
}

// Decode decodes AttributeType from json.
func (s *AttributeType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AttributeType to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Object:
		if err := s.Enum.Decode(d); err != nil {
			return err
		}
		s.Type = EnumAttributeType
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringAttributeType
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AttributeType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AttributeType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Enum) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Enum) encodeFields(e *jx.Encoder) {
	{
		if s.AllowCustomValues.Set {
			e.FieldStart("allow_custom_values")
			s.AllowCustomValues.Encode(e)
		}
	}
	{
		e.FieldStart("members")
		e.ArrStart()
		for _, elem := range s.Members {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfEnum = [2]string{
	0: "allow_custom_values",
	1: "members",
}

// Decode decodes Enum from json.
func (s *Enum) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Enum to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "allow_custom_values":
			if err := func() error {
				s.AllowCustomValues.Reset()
				if err := s.AllowCustomValues.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow_custom_values\"")
			}
		case "members":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Members = make([]EnumMembersItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem EnumMembersItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Members = append(s.Members, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"members\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Enum")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEnum) {
					name = jsonFieldsNameOfEnum[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Enum) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Enum) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EnumMembersItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EnumMembersItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.Note.Set {
			e.FieldStart("note")
			s.Note.Encode(e)
		}
	}
	{
		e.FieldStart("value")
		s.Value.Encode(e)
	}
	{
		if s.Brief.Set {
			e.FieldStart("brief")
			s.Brief.Encode(e)
		}
	}
}

var jsonFieldsNameOfEnumMembersItem = [4]string{
	0: "id",
	1: "note",
	2: "value",
	3: "brief",
}

// Decode decodes EnumMembersItem from json.
func (s *EnumMembersItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnumMembersItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "note":
			if err := func() error {
				s.Note.Reset()
				if err := s.Note.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"note\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		case "brief":
			if err := func() error {
				s.Brief.Reset()
				if err := s.Brief.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"brief\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnumMembersItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEnumMembersItem) {
					name = jsonFieldsNameOfEnumMembersItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EnumMembersItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnumMembersItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EnumMembersItemValue as json.
func (s EnumMembersItemValue) Encode(e *jx.Encoder) {
	switch s.Type {
	case StringEnumMembersItemValue:
		e.Str(s.String)
	case Float64EnumMembersItemValue:
		e.Float64(s.Float64)
	}
}

// Decode decodes EnumMembersItemValue from json.
func (s *EnumMembersItemValue) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnumMembersItemValue to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Number:
		v, err := d.Float64()
		s.Float64 = float64(v)
		if err != nil {
			return err
		}
		s.Type = Float64EnumMembersItemValue
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringEnumMembersItemValue
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EnumMembersItemValue) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnumMembersItemValue) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	o.Set = true
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RequirementLevel as json.
func (o OptRequirementLevel) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RequirementLevel from json.
func (o *OptRequirementLevel) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRequirementLevel to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRequirementLevel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRequirementLevel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RequirementLevel as json.
func (s RequirementLevel) Encode(e *jx.Encoder) {
	switch s.Type {
	case StringRequirementLevel:
		e.Str(s.String)
	case RequirementLevel1RequirementLevel:
		s.RequirementLevel1.Encode(e)
	}
}

// Decode decodes RequirementLevel from json.
func (s *RequirementLevel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RequirementLevel to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Object:
		if err := s.RequirementLevel1.Decode(d); err != nil {
			return err
		}
		s.Type = RequirementLevel1RequirementLevel
	case jx.String:
		v, err := d.Str()
		s.String = string(v)
		if err != nil {
			return err
		}
		s.Type = StringRequirementLevel
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RequirementLevel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RequirementLevel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s RequirementLevel1) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s RequirementLevel1) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes RequirementLevel1 from json.
func (s *RequirementLevel1) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RequirementLevel1 to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RequirementLevel1")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RequirementLevel1) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RequirementLevel1) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Type) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Type) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("groups")
		e.ArrStart()
		for _, elem := range s.Groups {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfType = [1]string{
	0: "groups",
}

// Decode decodes Type from json.
func (s *Type) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Type to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "groups":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Groups = make([]TypeGroupsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem TypeGroupsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Groups = append(s.Groups, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"groups\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Type")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfType) {
					name = jsonFieldsNameOfType[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Type) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Type) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TypeGroupsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TypeGroupsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.Prefix.Set {
			e.FieldStart("prefix")
			s.Prefix.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.Brief.Set {
			e.FieldStart("brief")
			s.Brief.Encode(e)
		}
	}
	{
		if s.Note.Set {
			e.FieldStart("note")
			s.Note.Encode(e)
		}
	}
	{
		if s.Attributes != nil {
			e.FieldStart("attributes")
			e.ArrStart()
			for _, elem := range s.Attributes {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfTypeGroupsItem = [6]string{
	0: "id",
	1: "prefix",
	2: "type",
	3: "brief",
	4: "note",
	5: "attributes",
}

// Decode decodes TypeGroupsItem from json.
func (s *TypeGroupsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TypeGroupsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "prefix":
			if err := func() error {
				s.Prefix.Reset()
				if err := s.Prefix.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prefix\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "brief":
			if err := func() error {
				s.Brief.Reset()
				if err := s.Brief.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"brief\"")
			}
		case "note":
			if err := func() error {
				s.Note.Reset()
				if err := s.Note.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"note\"")
			}
		case "attributes":
			if err := func() error {
				s.Attributes = make([]TypeGroupsItemAttributesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem TypeGroupsItemAttributesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Attributes = append(s.Attributes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attributes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TypeGroupsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTypeGroupsItem) {
					name = jsonFieldsNameOfTypeGroupsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TypeGroupsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TypeGroupsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TypeGroupsItemAttributesItem as json.
func (s TypeGroupsItemAttributesItem) Encode(e *jx.Encoder) {
	switch s.Type {
	case AttributeReferenceTypeGroupsItemAttributesItem:
		s.AttributeReference.Encode(e)
	case AttributeTypeGroupsItemAttributesItem:
		s.Attribute.Encode(e)
	}
}

func (s TypeGroupsItemAttributesItem) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case AttributeReferenceTypeGroupsItemAttributesItem:
		s.AttributeReference.encodeFields(e)
	case AttributeTypeGroupsItemAttributesItem:
		s.Attribute.encodeFields(e)
	}
}

// Decode decodes TypeGroupsItemAttributesItem from json.
func (s *TypeGroupsItemAttributesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TypeGroupsItemAttributesItem to nil")
	}
	// Sum type fields.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			switch string(key) {
			case "ref":
				match := AttributeReferenceTypeGroupsItemAttributesItem
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "id":
				match := AttributeTypeGroupsItemAttributesItem
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "type":
				match := AttributeTypeGroupsItemAttributesItem
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "stability":
				match := AttributeTypeGroupsItemAttributesItem
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case AttributeReferenceTypeGroupsItemAttributesItem:
		if err := s.AttributeReference.Decode(d); err != nil {
			return err
		}
	case AttributeTypeGroupsItemAttributesItem:
		if err := s.Attribute.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TypeGroupsItemAttributesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TypeGroupsItemAttributesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

func (s *Attribute) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Type.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "type",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s AttributeType) Validate() error {
	switch s.Type {
	case EnumAttributeType:
		if err := s.Enum.Validate(); err != nil {
			return err
		}
		return nil
	case StringAttributeType:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s *Enum) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if s.Members == nil {
			return errors.New("nil is invalid value")
		}
		var failures []validate.FieldError
		for i, elem := range s.Members {
			if err := func() error {
				if err := elem.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				failures = append(failures, validate.FieldError{
					Name:  fmt.Sprintf("[%d]", i),
					Error: err,
				})
			}
		}
		if len(failures) > 0 {
			return &validate.Error{Fields: failures}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "members",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *EnumMembersItem) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if err := s.Value.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "value",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s EnumMembersItemValue) Validate() error {
	switch s.Type {
	case StringEnumMembersItemValue:
		return nil // no validation needed
	case Float64EnumMembersItemValue:
		if err := (validate.Float{}).Validate(float64(s.Float64)); err != nil {
			return errors.Wrap(err, "float")
		}
		return nil
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s *Type) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if s.Groups == nil {
			return errors.New("nil is invalid value")
		}
		var failures []validate.FieldError
		for i, elem := range s.Groups {
			if err := func() error {
				if err := elem.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				failures = append(failures, validate.FieldError{
					Name:  fmt.Sprintf("[%d]", i),
					Error: err,
				})
			}
		}
		if len(failures) > 0 {
			return &validate.Error{Fields: failures}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "groups",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *TypeGroupsItem) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		var failures []validate.FieldError
		for i, elem := range s.Attributes {
			if err := func() error {
				if err := elem.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				failures = append(failures, validate.FieldError{
					Name:  fmt.Sprintf("[%d]", i),
					Error: err,
				})
			}
		}
		if len(failures) > 0 {
			return &validate.Error{Fields: failures}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "attributes",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s TypeGroupsItemAttributesItem) Validate() error {
	switch s.Type {
	case AttributeReferenceTypeGroupsItemAttributesItem:
		return nil // no validation needed
	case AttributeTypeGroupsItemAttributesItem:
		if err := s.Attribute.Validate(); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}
