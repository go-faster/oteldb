// Code generated by ogen, DO NOT EDIT.

package promapi

import (
	"github.com/go-faster/jx"

	std "encoding/json"
	"testing"

	"github.com/stretchr/testify/require"
)

func TestAlert_EncodeDecode(t *testing.T) {
	var typ Alert
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Alert
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAlertingRule_EncodeDecode(t *testing.T) {
	var typ AlertingRule
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AlertingRule
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAlertingRuleState_EncodeDecode(t *testing.T) {
	var typ AlertingRuleState
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AlertingRuleState
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBucket_EncodeDecode(t *testing.T) {
	var typ Bucket
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Bucket
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestData_EncodeDecode(t *testing.T) {
	var typ Data
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Data
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestExemplar_EncodeDecode(t *testing.T) {
	var typ Exemplar
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Exemplar
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestExemplars_EncodeDecode(t *testing.T) {
	var typ Exemplars
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Exemplars
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestExemplarsSet_EncodeDecode(t *testing.T) {
	var typ ExemplarsSet
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ExemplarsSet
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestFPoint_EncodeDecode(t *testing.T) {
	var typ FPoint
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 FPoint
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestFail_EncodeDecode(t *testing.T) {
	var typ Fail
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Fail
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestFailErrorType_EncodeDecode(t *testing.T) {
	var typ FailErrorType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 FailErrorType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestHPoint_EncodeDecode(t *testing.T) {
	var typ HPoint
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 HPoint
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestHistogram_EncodeDecode(t *testing.T) {
	var typ Histogram
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Histogram
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestHistogramOrValue_EncodeDecode(t *testing.T) {
	var typ HistogramOrValue
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 HistogramOrValue
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestLabelSet_EncodeDecode(t *testing.T) {
	var typ LabelSet
	typ = make(LabelSet)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 LabelSet
	typ2 = make(LabelSet)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestLabelValues_EncodeDecode(t *testing.T) {
	var typ LabelValues
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 LabelValues
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestLabelValuesResponse_EncodeDecode(t *testing.T) {
	var typ LabelValuesResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 LabelValuesResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestLabels_EncodeDecode(t *testing.T) {
	var typ Labels
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Labels
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestLabelsResponse_EncodeDecode(t *testing.T) {
	var typ LabelsResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 LabelsResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestMatrix_EncodeDecode(t *testing.T) {
	var typ Matrix
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Matrix
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestMatrixResultItem_EncodeDecode(t *testing.T) {
	var typ MatrixResultItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 MatrixResultItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestMatrixResultItemMetric_EncodeDecode(t *testing.T) {
	var typ MatrixResultItemMetric
	typ = make(MatrixResultItemMetric)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 MatrixResultItemMetric
	typ2 = make(MatrixResultItemMetric)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestMetadata_EncodeDecode(t *testing.T) {
	var typ Metadata
	typ = make(Metadata)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Metadata
	typ2 = make(Metadata)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestMetadataResponse_EncodeDecode(t *testing.T) {
	var typ MetadataResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 MetadataResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestMetricMetadata_EncodeDecode(t *testing.T) {
	var typ MetricMetadata
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 MetricMetadata
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestMetricMetadataType_EncodeDecode(t *testing.T) {
	var typ MetricMetadataType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 MetricMetadataType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestQueryExemplarsResponse_EncodeDecode(t *testing.T) {
	var typ QueryExemplarsResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 QueryExemplarsResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestQueryResponse_EncodeDecode(t *testing.T) {
	var typ QueryResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 QueryResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRecordingRule_EncodeDecode(t *testing.T) {
	var typ RecordingRule
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RecordingRule
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRule_EncodeDecode(t *testing.T) {
	var typ Rule
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Rule
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRuleGroup_EncodeDecode(t *testing.T) {
	var typ RuleGroup
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RuleGroup
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRuleHealth_EncodeDecode(t *testing.T) {
	var typ RuleHealth
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RuleHealth
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRules_EncodeDecode(t *testing.T) {
	var typ Rules
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Rules
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRulesResponse_EncodeDecode(t *testing.T) {
	var typ RulesResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RulesResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSample_EncodeDecode(t *testing.T) {
	var typ Sample
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Sample
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestScalar_EncodeDecode(t *testing.T) {
	var typ Scalar
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Scalar
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSeries_EncodeDecode(t *testing.T) {
	var typ Series
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Series
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSeriesResponse_EncodeDecode(t *testing.T) {
	var typ SeriesResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SeriesResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestString_EncodeDecode(t *testing.T) {
	var typ String
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 String
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestStringValue_EncodeDecode(t *testing.T) {
	var typ StringValue
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 StringValue
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestVector_EncodeDecode(t *testing.T) {
	var typ Vector
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Vector
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestVectorResultItem_EncodeDecode(t *testing.T) {
	var typ VectorResultItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 VectorResultItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestVectorResultItemMetric_EncodeDecode(t *testing.T) {
	var typ VectorResultItemMetric
	typ = make(VectorResultItemMetric)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 VectorResultItemMetric
	typ2 = make(VectorResultItemMetric)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
