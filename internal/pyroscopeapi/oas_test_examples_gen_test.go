// Code generated by ogen, DO NOT EDIT.

package pyroscopeapi

import (
	"github.com/go-faster/jx"

	std "encoding/json"
	"testing"

	"github.com/stretchr/testify/require"
)

func TestApplicationMetadata_EncodeDecode(t *testing.T) {
	var typ ApplicationMetadata
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ApplicationMetadata
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestApplicationMetadataUnits_EncodeDecode(t *testing.T) {
	var typ ApplicationMetadataUnits
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ApplicationMetadataUnits
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestError_EncodeDecode(t *testing.T) {
	var typ Error
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Error
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestFlamebearerMetadataV1_EncodeDecode(t *testing.T) {
	var typ FlamebearerMetadataV1
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 FlamebearerMetadataV1
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestFlamebearerMetadataV1Units_EncodeDecode(t *testing.T) {
	var typ FlamebearerMetadataV1Units
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 FlamebearerMetadataV1Units
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestFlamebearerProfileV1_EncodeDecode(t *testing.T) {
	var typ FlamebearerProfileV1
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 FlamebearerProfileV1
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestFlamebearerProfileV1Groups_EncodeDecode(t *testing.T) {
	var typ FlamebearerProfileV1Groups
	typ = make(FlamebearerProfileV1Groups)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 FlamebearerProfileV1Groups
	typ2 = make(FlamebearerProfileV1Groups)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestFlamebearerTimelineV1_EncodeDecode(t *testing.T) {
	var typ FlamebearerTimelineV1
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 FlamebearerTimelineV1
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestFlamebearerTimelineV1Watermarks_EncodeDecode(t *testing.T) {
	var typ FlamebearerTimelineV1Watermarks
	typ = make(FlamebearerTimelineV1Watermarks)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 FlamebearerTimelineV1Watermarks
	typ2 = make(FlamebearerTimelineV1Watermarks)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestFlamebearerV1_EncodeDecode(t *testing.T) {
	var typ FlamebearerV1
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 FlamebearerV1
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestHeatmap_EncodeDecode(t *testing.T) {
	var typ Heatmap
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Heatmap
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestLabelValues_EncodeDecode(t *testing.T) {
	var typ LabelValues
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 LabelValues
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestLabels_EncodeDecode(t *testing.T) {
	var typ Labels
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Labels
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
