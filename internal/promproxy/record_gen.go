// Code generated by ogen, DO NOT EDIT.

package promproxy

import (
	"fmt"
	"math/bits"
	"strconv"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"

	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/validate"
)

// Ref: #/definitions/instantQuery
type InstantQuery struct {
	Query       string      `json:"query"`
	Time        OptDateTime `json:"time"`
	Title       OptString   `json:"title"`
	Description OptString   `json:"description"`
}

// GetQuery returns the value of Query.
func (s *InstantQuery) GetQuery() string {
	return s.Query
}

// GetTime returns the value of Time.
func (s *InstantQuery) GetTime() OptDateTime {
	return s.Time
}

// GetTitle returns the value of Title.
func (s *InstantQuery) GetTitle() OptString {
	return s.Title
}

// GetDescription returns the value of Description.
func (s *InstantQuery) GetDescription() OptString {
	return s.Description
}

// SetQuery sets the value of Query.
func (s *InstantQuery) SetQuery(val string) {
	s.Query = val
}

// SetTime sets the value of Time.
func (s *InstantQuery) SetTime(val OptDateTime) {
	s.Time = val
}

// SetTitle sets the value of Title.
func (s *InstantQuery) SetTitle(val OptString) {
	s.Title = val
}

// SetDescription sets the value of Description.
func (s *InstantQuery) SetDescription(val OptString) {
	s.Description = val
}

// NewOptDateTime returns new OptDateTime with value set to v.
func NewOptDateTime(v time.Time) OptDateTime {
	return OptDateTime{
		Value: v,
		Set:   true,
	}
}

// OptDateTime is optional time.Time.
type OptDateTime struct {
	Value time.Time
	Set   bool
}

// IsSet returns true if OptDateTime was set.
func (o OptDateTime) IsSet() bool { return o.Set }

// Reset unsets value.
func (o *OptDateTime) Reset() {
	var v time.Time
	o.Value = v
	o.Set = false
}

// SetTo sets value to v.
func (o *OptDateTime) SetTo(v time.Time) {
	o.Set = true
	o.Value = v
}

// Get returns value and boolean that denotes whether value was set.
func (o OptDateTime) Get() (v time.Time, ok bool) {
	if !o.Set {
		return v, false
	}
	return o.Value, true
}

// Or returns value if set, or given parameter if does not.
func (o OptDateTime) Or(d time.Time) time.Time {
	if v, ok := o.Get(); ok {
		return v
	}
	return d
}

// NewOptInt returns new OptInt with value set to v.
func NewOptInt(v int) OptInt {
	return OptInt{
		Value: v,
		Set:   true,
	}
}

// OptInt is optional int.
type OptInt struct {
	Value int
	Set   bool
}

// IsSet returns true if OptInt was set.
func (o OptInt) IsSet() bool { return o.Set }

// Reset unsets value.
func (o *OptInt) Reset() {
	var v int
	o.Value = v
	o.Set = false
}

// SetTo sets value to v.
func (o *OptInt) SetTo(v int) {
	o.Set = true
	o.Value = v
}

// Get returns value and boolean that denotes whether value was set.
func (o OptInt) Get() (v int, ok bool) {
	if !o.Set {
		return v, false
	}
	return o.Value, true
}

// Or returns value if set, or given parameter if does not.
func (o OptInt) Or(d int) int {
	if v, ok := o.Get(); ok {
		return v
	}
	return d
}

// NewOptString returns new OptString with value set to v.
func NewOptString(v string) OptString {
	return OptString{
		Value: v,
		Set:   true,
	}
}

// OptString is optional string.
type OptString struct {
	Value string
	Set   bool
}

// IsSet returns true if OptString was set.
func (o OptString) IsSet() bool { return o.Set }

// Reset unsets value.
func (o *OptString) Reset() {
	var v string
	o.Value = v
	o.Set = false
}

// SetTo sets value to v.
func (o *OptString) SetTo(v string) {
	o.Set = true
	o.Value = v
}

// Get returns value and boolean that denotes whether value was set.
func (o OptString) Get() (v string, ok bool) {
	if !o.Set {
		return v, false
	}
	return o.Value, true
}

// Or returns value if set, or given parameter if does not.
func (o OptString) Or(d string) string {
	if v, ok := o.Get(); ok {
		return v
	}
	return d
}

// Ref: #/definitions/query
// Query represents sum type.
type Query struct {
	Type         QueryType // switch on this field
	RangeQuery   RangeQuery
	InstantQuery InstantQuery
	SeriesQuery  SeriesQuery
}

// QueryType is oneOf type of Query.
type QueryType string

// Possible values for QueryType.
const (
	RangeQueryQuery   QueryType = "RangeQuery"
	InstantQueryQuery QueryType = "InstantQuery"
	SeriesQueryQuery  QueryType = "SeriesQuery"
)

// IsRangeQuery reports whether Query is RangeQuery.
func (s Query) IsRangeQuery() bool { return s.Type == RangeQueryQuery }

// IsInstantQuery reports whether Query is InstantQuery.
func (s Query) IsInstantQuery() bool { return s.Type == InstantQueryQuery }

// IsSeriesQuery reports whether Query is SeriesQuery.
func (s Query) IsSeriesQuery() bool { return s.Type == SeriesQueryQuery }

// SetRangeQuery sets Query to RangeQuery.
func (s *Query) SetRangeQuery(v RangeQuery) {
	s.Type = RangeQueryQuery
	s.RangeQuery = v
}

// GetRangeQuery returns RangeQuery and true boolean if Query is RangeQuery.
func (s Query) GetRangeQuery() (v RangeQuery, ok bool) {
	if !s.IsRangeQuery() {
		return v, false
	}
	return s.RangeQuery, true
}

// NewRangeQueryQuery returns new Query from RangeQuery.
func NewRangeQueryQuery(v RangeQuery) Query {
	var s Query
	s.SetRangeQuery(v)
	return s
}

// SetInstantQuery sets Query to InstantQuery.
func (s *Query) SetInstantQuery(v InstantQuery) {
	s.Type = InstantQueryQuery
	s.InstantQuery = v
}

// GetInstantQuery returns InstantQuery and true boolean if Query is InstantQuery.
func (s Query) GetInstantQuery() (v InstantQuery, ok bool) {
	if !s.IsInstantQuery() {
		return v, false
	}
	return s.InstantQuery, true
}

// NewInstantQueryQuery returns new Query from InstantQuery.
func NewInstantQueryQuery(v InstantQuery) Query {
	var s Query
	s.SetInstantQuery(v)
	return s
}

// SetSeriesQuery sets Query to SeriesQuery.
func (s *Query) SetSeriesQuery(v SeriesQuery) {
	s.Type = SeriesQueryQuery
	s.SeriesQuery = v
}

// GetSeriesQuery returns SeriesQuery and true boolean if Query is SeriesQuery.
func (s Query) GetSeriesQuery() (v SeriesQuery, ok bool) {
	if !s.IsSeriesQuery() {
		return v, false
	}
	return s.SeriesQuery, true
}

// NewSeriesQueryQuery returns new Query from SeriesQuery.
func NewSeriesQueryQuery(v SeriesQuery) Query {
	var s Query
	s.SetSeriesQuery(v)
	return s
}

// Ref: #/definitions/rangeQuery
type RangeQuery struct {
	Query string      `json:"query"`
	Start OptDateTime `json:"start"`
	End   OptDateTime `json:"end"`
	// Step in seconds.
	Step        OptInt    `json:"step"`
	Title       OptString `json:"title"`
	Description OptString `json:"description"`
}

// GetQuery returns the value of Query.
func (s *RangeQuery) GetQuery() string {
	return s.Query
}

// GetStart returns the value of Start.
func (s *RangeQuery) GetStart() OptDateTime {
	return s.Start
}

// GetEnd returns the value of End.
func (s *RangeQuery) GetEnd() OptDateTime {
	return s.End
}

// GetStep returns the value of Step.
func (s *RangeQuery) GetStep() OptInt {
	return s.Step
}

// GetTitle returns the value of Title.
func (s *RangeQuery) GetTitle() OptString {
	return s.Title
}

// GetDescription returns the value of Description.
func (s *RangeQuery) GetDescription() OptString {
	return s.Description
}

// SetQuery sets the value of Query.
func (s *RangeQuery) SetQuery(val string) {
	s.Query = val
}

// SetStart sets the value of Start.
func (s *RangeQuery) SetStart(val OptDateTime) {
	s.Start = val
}

// SetEnd sets the value of End.
func (s *RangeQuery) SetEnd(val OptDateTime) {
	s.End = val
}

// SetStep sets the value of Step.
func (s *RangeQuery) SetStep(val OptInt) {
	s.Step = val
}

// SetTitle sets the value of Title.
func (s *RangeQuery) SetTitle(val OptString) {
	s.Title = val
}

// SetDescription sets the value of Description.
func (s *RangeQuery) SetDescription(val OptString) {
	s.Description = val
}

type Record struct {
	Start   OptDateTime    `json:"start"`
	End     OptDateTime    `json:"end"`
	Step    OptInt         `json:"step"`
	Series  []SeriesQuery  `json:"series"`
	Instant []InstantQuery `json:"instant"`
	Range   []RangeQuery   `json:"range"`
	Queries []Query        `json:"queries"`
}

// GetStart returns the value of Start.
func (s *Record) GetStart() OptDateTime {
	return s.Start
}

// GetEnd returns the value of End.
func (s *Record) GetEnd() OptDateTime {
	return s.End
}

// GetStep returns the value of Step.
func (s *Record) GetStep() OptInt {
	return s.Step
}

// GetSeries returns the value of Series.
func (s *Record) GetSeries() []SeriesQuery {
	return s.Series
}

// GetInstant returns the value of Instant.
func (s *Record) GetInstant() []InstantQuery {
	return s.Instant
}

// GetRange returns the value of Range.
func (s *Record) GetRange() []RangeQuery {
	return s.Range
}

// GetQueries returns the value of Queries.
func (s *Record) GetQueries() []Query {
	return s.Queries
}

// SetStart sets the value of Start.
func (s *Record) SetStart(val OptDateTime) {
	s.Start = val
}

// SetEnd sets the value of End.
func (s *Record) SetEnd(val OptDateTime) {
	s.End = val
}

// SetStep sets the value of Step.
func (s *Record) SetStep(val OptInt) {
	s.Step = val
}

// SetSeries sets the value of Series.
func (s *Record) SetSeries(val []SeriesQuery) {
	s.Series = val
}

// SetInstant sets the value of Instant.
func (s *Record) SetInstant(val []InstantQuery) {
	s.Instant = val
}

// SetRange sets the value of Range.
func (s *Record) SetRange(val []RangeQuery) {
	s.Range = val
}

// SetQueries sets the value of Queries.
func (s *Record) SetQueries(val []Query) {
	s.Queries = val
}

// Ref: #/definitions/seriesQuery
type SeriesQuery struct {
	Matchers    []string    `json:"matchers"`
	Start       OptDateTime `json:"start"`
	End         OptDateTime `json:"end"`
	Title       OptString   `json:"title"`
	Description OptString   `json:"description"`
}

// GetMatchers returns the value of Matchers.
func (s *SeriesQuery) GetMatchers() []string {
	return s.Matchers
}

// GetStart returns the value of Start.
func (s *SeriesQuery) GetStart() OptDateTime {
	return s.Start
}

// GetEnd returns the value of End.
func (s *SeriesQuery) GetEnd() OptDateTime {
	return s.End
}

// GetTitle returns the value of Title.
func (s *SeriesQuery) GetTitle() OptString {
	return s.Title
}

// GetDescription returns the value of Description.
func (s *SeriesQuery) GetDescription() OptString {
	return s.Description
}

// SetMatchers sets the value of Matchers.
func (s *SeriesQuery) SetMatchers(val []string) {
	s.Matchers = val
}

// SetStart sets the value of Start.
func (s *SeriesQuery) SetStart(val OptDateTime) {
	s.Start = val
}

// SetEnd sets the value of End.
func (s *SeriesQuery) SetEnd(val OptDateTime) {
	s.End = val
}

// SetTitle sets the value of Title.
func (s *SeriesQuery) SetTitle(val OptString) {
	s.Title = val
}

// SetDescription sets the value of Description.
func (s *SeriesQuery) SetDescription(val OptString) {
	s.Description = val
}

// Encode implements json.Marshaler.
func (s *InstantQuery) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InstantQuery) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("query")
		e.Str(s.Query)
	}
	{
		if s.Time.Set {
			e.FieldStart("time")
			s.Time.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
}

var jsonFieldsNameOfInstantQuery = [4]string{
	0: "query",
	1: "time",
	2: "title",
	3: "description",
}

// Decode decodes InstantQuery from json.
func (s *InstantQuery) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InstantQuery to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "query":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Query = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"query\"")
			}
		case "time":
			if err := func() error {
				s.Time.Reset()
				if err := s.Time.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"time\"")
			}
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InstantQuery")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInstantQuery) {
					name = jsonFieldsNameOfInstantQuery[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InstantQuery) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InstantQuery) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes time.Time as json.
func (o OptDateTime) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptDateTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDateTime to nil")
	}
	o.Set = true
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDateTime) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDateTime)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDateTime) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDateTime)
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt to nil")
	}
	o.Set = true
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Query as json.
func (s Query) Encode(e *jx.Encoder) {
	switch s.Type {
	case RangeQueryQuery:
		s.RangeQuery.Encode(e)
	case InstantQueryQuery:
		s.InstantQuery.Encode(e)
	case SeriesQueryQuery:
		s.SeriesQuery.Encode(e)
	}
}

func (s Query) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case RangeQueryQuery:
		s.RangeQuery.encodeFields(e)
	case InstantQueryQuery:
		s.InstantQuery.encodeFields(e)
	case SeriesQueryQuery:
		s.SeriesQuery.encodeFields(e)
	}
}

// Decode decodes Query from json.
func (s *Query) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Query to nil")
	}
	// Sum type fields.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			switch string(key) {
			case "step":
				match := RangeQueryQuery
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "time":
				match := InstantQueryQuery
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "matchers":
				match := SeriesQueryQuery
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case RangeQueryQuery:
		if err := s.RangeQuery.Decode(d); err != nil {
			return err
		}
	case InstantQueryQuery:
		if err := s.InstantQuery.Decode(d); err != nil {
			return err
		}
	case SeriesQueryQuery:
		if err := s.SeriesQuery.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Query) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Query) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RangeQuery) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RangeQuery) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("query")
		e.Str(s.Query)
	}
	{
		if s.Start.Set {
			e.FieldStart("start")
			s.Start.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.End.Set {
			e.FieldStart("end")
			s.End.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Step.Set {
			e.FieldStart("step")
			s.Step.Encode(e)
		}
	}
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
}

var jsonFieldsNameOfRangeQuery = [6]string{
	0: "query",
	1: "start",
	2: "end",
	3: "step",
	4: "title",
	5: "description",
}

// Decode decodes RangeQuery from json.
func (s *RangeQuery) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RangeQuery to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "query":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Query = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"query\"")
			}
		case "start":
			if err := func() error {
				s.Start.Reset()
				if err := s.Start.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start\"")
			}
		case "end":
			if err := func() error {
				s.End.Reset()
				if err := s.End.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end\"")
			}
		case "step":
			if err := func() error {
				s.Step.Reset()
				if err := s.Step.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"step\"")
			}
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RangeQuery")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRangeQuery) {
					name = jsonFieldsNameOfRangeQuery[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RangeQuery) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RangeQuery) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Record) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Record) encodeFields(e *jx.Encoder) {
	{
		if s.Start.Set {
			e.FieldStart("start")
			s.Start.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.End.Set {
			e.FieldStart("end")
			s.End.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Step.Set {
			e.FieldStart("step")
			s.Step.Encode(e)
		}
	}
	{
		if s.Series != nil {
			e.FieldStart("series")
			e.ArrStart()
			for _, elem := range s.Series {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Instant != nil {
			e.FieldStart("instant")
			e.ArrStart()
			for _, elem := range s.Instant {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Range != nil {
			e.FieldStart("range")
			e.ArrStart()
			for _, elem := range s.Range {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Queries != nil {
			e.FieldStart("queries")
			e.ArrStart()
			for _, elem := range s.Queries {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfRecord = [7]string{
	0: "start",
	1: "end",
	2: "step",
	3: "series",
	4: "instant",
	5: "range",
	6: "queries",
}

// Decode decodes Record from json.
func (s *Record) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Record to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "start":
			if err := func() error {
				s.Start.Reset()
				if err := s.Start.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start\"")
			}
		case "end":
			if err := func() error {
				s.End.Reset()
				if err := s.End.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end\"")
			}
		case "step":
			if err := func() error {
				s.Step.Reset()
				if err := s.Step.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"step\"")
			}
		case "series":
			if err := func() error {
				s.Series = make([]SeriesQuery, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SeriesQuery
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Series = append(s.Series, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"series\"")
			}
		case "instant":
			if err := func() error {
				s.Instant = make([]InstantQuery, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem InstantQuery
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Instant = append(s.Instant, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instant\"")
			}
		case "range":
			if err := func() error {
				s.Range = make([]RangeQuery, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem RangeQuery
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Range = append(s.Range, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"range\"")
			}
		case "queries":
			if err := func() error {
				s.Queries = make([]Query, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Query
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Queries = append(s.Queries, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"queries\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Record")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Record) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Record) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SeriesQuery) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SeriesQuery) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("matchers")
		e.ArrStart()
		for _, elem := range s.Matchers {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		if s.Start.Set {
			e.FieldStart("start")
			s.Start.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.End.Set {
			e.FieldStart("end")
			s.End.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
}

var jsonFieldsNameOfSeriesQuery = [5]string{
	0: "matchers",
	1: "start",
	2: "end",
	3: "title",
	4: "description",
}

// Decode decodes SeriesQuery from json.
func (s *SeriesQuery) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SeriesQuery to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "matchers":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Matchers = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Matchers = append(s.Matchers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"matchers\"")
			}
		case "start":
			if err := func() error {
				s.Start.Reset()
				if err := s.Start.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start\"")
			}
		case "end":
			if err := func() error {
				s.End.Reset()
				if err := s.End.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end\"")
			}
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SeriesQuery")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSeriesQuery) {
					name = jsonFieldsNameOfSeriesQuery[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SeriesQuery) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SeriesQuery) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

func (s Query) Validate() error {
	switch s.Type {
	case RangeQueryQuery:
		return nil // no validation needed
	case InstantQueryQuery:
		return nil // no validation needed
	case SeriesQueryQuery:
		if err := s.SeriesQuery.Validate(); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s *Record) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		var failures []validate.FieldError
		for i, elem := range s.Series {
			if err := func() error {
				if err := elem.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				failures = append(failures, validate.FieldError{
					Name:  fmt.Sprintf("[%d]", i),
					Error: err,
				})
			}
		}
		if len(failures) > 0 {
			return &validate.Error{Fields: failures}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "series",
			Error: err,
		})
	}
	if err := func() error {
		var failures []validate.FieldError
		for i, elem := range s.Queries {
			if err := func() error {
				if err := elem.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				failures = append(failures, validate.FieldError{
					Name:  fmt.Sprintf("[%d]", i),
					Error: err,
				})
			}
		}
		if len(failures) > 0 {
			return &validate.Error{Fields: failures}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "queries",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *SeriesQuery) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if s.Matchers == nil {
			return errors.New("nil is invalid value")
		}
		if err := (validate.Array{
			MinLength:    1,
			MinLengthSet: true,
			MaxLength:    0,
			MaxLengthSet: false,
		}).ValidateLength(len(s.Matchers)); err != nil {
			return errors.Wrap(err, "array")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "matchers",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
