// Code generated by ogen, DO NOT EDIT.

package promproxy

import (
	"fmt"
	"math/bits"
	"strconv"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"

	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/validate"
)

// Ref: #/definitions/instantQuery
type InstantQuery struct {
	Query string      `json:"query"`
	Time  OptDateTime `json:"time"`
}

// GetQuery returns the value of Query.
func (s *InstantQuery) GetQuery() string {
	return s.Query
}

// GetTime returns the value of Time.
func (s *InstantQuery) GetTime() OptDateTime {
	return s.Time
}

// SetQuery sets the value of Query.
func (s *InstantQuery) SetQuery(val string) {
	s.Query = val
}

// SetTime sets the value of Time.
func (s *InstantQuery) SetTime(val OptDateTime) {
	s.Time = val
}

// NewOptDateTime returns new OptDateTime with value set to v.
func NewOptDateTime(v time.Time) OptDateTime {
	return OptDateTime{
		Value: v,
		Set:   true,
	}
}

// OptDateTime is optional time.Time.
type OptDateTime struct {
	Value time.Time
	Set   bool
}

// IsSet returns true if OptDateTime was set.
func (o OptDateTime) IsSet() bool { return o.Set }

// Reset unsets value.
func (o *OptDateTime) Reset() {
	var v time.Time
	o.Value = v
	o.Set = false
}

// SetTo sets value to v.
func (o *OptDateTime) SetTo(v time.Time) {
	o.Set = true
	o.Value = v
}

// Get returns value and boolean that denotes whether value was set.
func (o OptDateTime) Get() (v time.Time, ok bool) {
	if !o.Set {
		return v, false
	}
	return o.Value, true
}

// Or returns value if set, or given parameter if does not.
func (o OptDateTime) Or(d time.Time) time.Time {
	if v, ok := o.Get(); ok {
		return v
	}
	return d
}

// Ref: #/definitions/query
// Query represents sum type.
type Query struct {
	Type         QueryType // switch on this field
	RangeQuery   RangeQuery
	InstantQuery InstantQuery
	SeriesQuery  SeriesQuery
}

// QueryType is oneOf type of Query.
type QueryType string

// Possible values for QueryType.
const (
	RangeQueryQuery   QueryType = "RangeQuery"
	InstantQueryQuery QueryType = "InstantQuery"
	SeriesQueryQuery  QueryType = "SeriesQuery"
)

// IsRangeQuery reports whether Query is RangeQuery.
func (s Query) IsRangeQuery() bool { return s.Type == RangeQueryQuery }

// IsInstantQuery reports whether Query is InstantQuery.
func (s Query) IsInstantQuery() bool { return s.Type == InstantQueryQuery }

// IsSeriesQuery reports whether Query is SeriesQuery.
func (s Query) IsSeriesQuery() bool { return s.Type == SeriesQueryQuery }

// SetRangeQuery sets Query to RangeQuery.
func (s *Query) SetRangeQuery(v RangeQuery) {
	s.Type = RangeQueryQuery
	s.RangeQuery = v
}

// GetRangeQuery returns RangeQuery and true boolean if Query is RangeQuery.
func (s Query) GetRangeQuery() (v RangeQuery, ok bool) {
	if !s.IsRangeQuery() {
		return v, false
	}
	return s.RangeQuery, true
}

// NewRangeQueryQuery returns new Query from RangeQuery.
func NewRangeQueryQuery(v RangeQuery) Query {
	var s Query
	s.SetRangeQuery(v)
	return s
}

// SetInstantQuery sets Query to InstantQuery.
func (s *Query) SetInstantQuery(v InstantQuery) {
	s.Type = InstantQueryQuery
	s.InstantQuery = v
}

// GetInstantQuery returns InstantQuery and true boolean if Query is InstantQuery.
func (s Query) GetInstantQuery() (v InstantQuery, ok bool) {
	if !s.IsInstantQuery() {
		return v, false
	}
	return s.InstantQuery, true
}

// NewInstantQueryQuery returns new Query from InstantQuery.
func NewInstantQueryQuery(v InstantQuery) Query {
	var s Query
	s.SetInstantQuery(v)
	return s
}

// SetSeriesQuery sets Query to SeriesQuery.
func (s *Query) SetSeriesQuery(v SeriesQuery) {
	s.Type = SeriesQueryQuery
	s.SeriesQuery = v
}

// GetSeriesQuery returns SeriesQuery and true boolean if Query is SeriesQuery.
func (s Query) GetSeriesQuery() (v SeriesQuery, ok bool) {
	if !s.IsSeriesQuery() {
		return v, false
	}
	return s.SeriesQuery, true
}

// NewSeriesQueryQuery returns new Query from SeriesQuery.
func NewSeriesQueryQuery(v SeriesQuery) Query {
	var s Query
	s.SetSeriesQuery(v)
	return s
}

// Ref: #/definitions/rangeQuery
type RangeQuery struct {
	Query string    `json:"query"`
	Start time.Time `json:"start"`
	End   time.Time `json:"end"`
	// Step in seconds.
	Step int `json:"step"`
}

// GetQuery returns the value of Query.
func (s *RangeQuery) GetQuery() string {
	return s.Query
}

// GetStart returns the value of Start.
func (s *RangeQuery) GetStart() time.Time {
	return s.Start
}

// GetEnd returns the value of End.
func (s *RangeQuery) GetEnd() time.Time {
	return s.End
}

// GetStep returns the value of Step.
func (s *RangeQuery) GetStep() int {
	return s.Step
}

// SetQuery sets the value of Query.
func (s *RangeQuery) SetQuery(val string) {
	s.Query = val
}

// SetStart sets the value of Start.
func (s *RangeQuery) SetStart(val time.Time) {
	s.Start = val
}

// SetEnd sets the value of End.
func (s *RangeQuery) SetEnd(val time.Time) {
	s.End = val
}

// SetStep sets the value of Step.
func (s *RangeQuery) SetStep(val int) {
	s.Step = val
}

type Record struct {
	Queries []Query `json:"queries"`
}

// GetQueries returns the value of Queries.
func (s *Record) GetQueries() []Query {
	return s.Queries
}

// SetQueries sets the value of Queries.
func (s *Record) SetQueries(val []Query) {
	s.Queries = val
}

// Ref: #/definitions/seriesQuery
type SeriesQuery struct {
	Matchers []string    `json:"matchers"`
	Start    OptDateTime `json:"start"`
	End      OptDateTime `json:"end"`
}

// GetMatchers returns the value of Matchers.
func (s *SeriesQuery) GetMatchers() []string {
	return s.Matchers
}

// GetStart returns the value of Start.
func (s *SeriesQuery) GetStart() OptDateTime {
	return s.Start
}

// GetEnd returns the value of End.
func (s *SeriesQuery) GetEnd() OptDateTime {
	return s.End
}

// SetMatchers sets the value of Matchers.
func (s *SeriesQuery) SetMatchers(val []string) {
	s.Matchers = val
}

// SetStart sets the value of Start.
func (s *SeriesQuery) SetStart(val OptDateTime) {
	s.Start = val
}

// SetEnd sets the value of End.
func (s *SeriesQuery) SetEnd(val OptDateTime) {
	s.End = val
}

// Encode implements json.Marshaler.
func (s *InstantQuery) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InstantQuery) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("query")
		e.Str(s.Query)
	}
	{
		if s.Time.Set {
			e.FieldStart("time")
			s.Time.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfInstantQuery = [2]string{
	0: "query",
	1: "time",
}

// Decode decodes InstantQuery from json.
func (s *InstantQuery) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InstantQuery to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "query":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Query = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"query\"")
			}
		case "time":
			if err := func() error {
				s.Time.Reset()
				if err := s.Time.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"time\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InstantQuery")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInstantQuery) {
					name = jsonFieldsNameOfInstantQuery[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InstantQuery) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InstantQuery) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes time.Time as json.
func (o OptDateTime) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptDateTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDateTime to nil")
	}
	o.Set = true
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDateTime) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDateTime)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDateTime) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDateTime)
}

// Encode encodes Query as json.
func (s Query) Encode(e *jx.Encoder) {
	switch s.Type {
	case RangeQueryQuery:
		s.RangeQuery.Encode(e)
	case InstantQueryQuery:
		s.InstantQuery.Encode(e)
	case SeriesQueryQuery:
		s.SeriesQuery.Encode(e)
	}
}

func (s Query) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case RangeQueryQuery:
		s.RangeQuery.encodeFields(e)
	case InstantQueryQuery:
		s.InstantQuery.encodeFields(e)
	case SeriesQueryQuery:
		s.SeriesQuery.encodeFields(e)
	}
}

// Decode decodes Query from json.
func (s *Query) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Query to nil")
	}
	// Sum type fields.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			switch string(key) {
			case "step":
				match := RangeQueryQuery
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "time":
				match := InstantQueryQuery
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "matchers":
				match := SeriesQueryQuery
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case RangeQueryQuery:
		if err := s.RangeQuery.Decode(d); err != nil {
			return err
		}
	case InstantQueryQuery:
		if err := s.InstantQuery.Decode(d); err != nil {
			return err
		}
	case SeriesQueryQuery:
		if err := s.SeriesQuery.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Query) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Query) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RangeQuery) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RangeQuery) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("query")
		e.Str(s.Query)
	}
	{
		e.FieldStart("start")
		json.EncodeDateTime(e, s.Start)
	}
	{
		e.FieldStart("end")
		json.EncodeDateTime(e, s.End)
	}
	{
		e.FieldStart("step")
		e.Int(s.Step)
	}
}

var jsonFieldsNameOfRangeQuery = [4]string{
	0: "query",
	1: "start",
	2: "end",
	3: "step",
}

// Decode decodes RangeQuery from json.
func (s *RangeQuery) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RangeQuery to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "query":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Query = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"query\"")
			}
		case "start":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.Start = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start\"")
			}
		case "end":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.End = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end\"")
			}
		case "step":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Step = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"step\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RangeQuery")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRangeQuery) {
					name = jsonFieldsNameOfRangeQuery[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RangeQuery) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RangeQuery) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Record) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Record) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("queries")
		e.ArrStart()
		for _, elem := range s.Queries {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfRecord = [1]string{
	0: "queries",
}

// Decode decodes Record from json.
func (s *Record) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Record to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "queries":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Queries = make([]Query, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Query
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Queries = append(s.Queries, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"queries\"")
			}
		default:
			return errors.Errorf("unexpected field %q", k)
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Record")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRecord) {
					name = jsonFieldsNameOfRecord[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Record) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Record) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SeriesQuery) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SeriesQuery) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("matchers")
		e.ArrStart()
		for _, elem := range s.Matchers {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		if s.Start.Set {
			e.FieldStart("start")
			s.Start.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.End.Set {
			e.FieldStart("end")
			s.End.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfSeriesQuery = [3]string{
	0: "matchers",
	1: "start",
	2: "end",
}

// Decode decodes SeriesQuery from json.
func (s *SeriesQuery) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SeriesQuery to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "matchers":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Matchers = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Matchers = append(s.Matchers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"matchers\"")
			}
		case "start":
			if err := func() error {
				s.Start.Reset()
				if err := s.Start.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start\"")
			}
		case "end":
			if err := func() error {
				s.End.Reset()
				if err := s.End.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"end\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SeriesQuery")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSeriesQuery) {
					name = jsonFieldsNameOfSeriesQuery[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SeriesQuery) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SeriesQuery) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

func (s Query) Validate() error {
	switch s.Type {
	case RangeQueryQuery:
		return nil // no validation needed
	case InstantQueryQuery:
		return nil // no validation needed
	case SeriesQueryQuery:
		if err := s.SeriesQuery.Validate(); err != nil {
			return err
		}
		return nil
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s *Record) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if s.Queries == nil {
			return errors.New("nil is invalid value")
		}
		var failures []validate.FieldError
		for i, elem := range s.Queries {
			if err := func() error {
				if err := elem.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				failures = append(failures, validate.FieldError{
					Name:  fmt.Sprintf("[%d]", i),
					Error: err,
				})
			}
		}
		if len(failures) > 0 {
			return &validate.Error{Fields: failures}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "queries",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}

func (s *SeriesQuery) Validate() error {
	if s == nil {
		return validate.ErrNilPointer
	}

	var failures []validate.FieldError
	if err := func() error {
		if s.Matchers == nil {
			return errors.New("nil is invalid value")
		}
		if err := (validate.Array{
			MinLength:    1,
			MinLengthSet: true,
			MaxLength:    0,
			MaxLengthSet: false,
		}).ValidateLength(len(s.Matchers)); err != nil {
			return errors.Wrap(err, "array")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "matchers",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
