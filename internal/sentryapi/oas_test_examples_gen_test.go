// Code generated by ogen, DO NOT EDIT.

package sentryapi

import (
	"github.com/go-faster/jx"

	std "encoding/json"
	"testing"

	"github.com/stretchr/testify/require"
)

func TestBreadcrumb_EncodeDecode(t *testing.T) {
	var typ Breadcrumb
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Breadcrumb
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBreadcrumbData_EncodeDecode(t *testing.T) {
	var typ BreadcrumbData
	typ = make(BreadcrumbData)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BreadcrumbData
	typ2 = make(BreadcrumbData)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestContext_EncodeDecode(t *testing.T) {
	var typ Context
	typ = make(Context)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Context
	typ2 = make(Context)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDebugImage_EncodeDecode(t *testing.T) {
	var typ DebugImage
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DebugImage
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDebugMeta_EncodeDecode(t *testing.T) {
	var typ DebugMeta
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DebugMeta
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDebugMetaSdkInfo_EncodeDecode(t *testing.T) {
	var typ DebugMetaSdkInfo
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DebugMetaSdkInfo
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestErrno_EncodeDecode(t *testing.T) {
	var typ Errno
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Errno
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestError_EncodeDecode(t *testing.T) {
	var typ Error
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Error
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEvent_EncodeDecode(t *testing.T) {
	var typ Event
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Event
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEventContexts_EncodeDecode(t *testing.T) {
	var typ EventContexts
	typ = make(EventContexts)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EventContexts
	typ2 = make(EventContexts)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEventExtra_EncodeDecode(t *testing.T) {
	var typ EventExtra
	typ = make(EventExtra)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EventExtra
	typ2 = make(EventExtra)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEventID_EncodeDecode(t *testing.T) {
	var typ EventID
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EventID
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEventModules_EncodeDecode(t *testing.T) {
	var typ EventModules
	typ = make(EventModules)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EventModules
	typ2 = make(EventModules)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEventTags_EncodeDecode(t *testing.T) {
	var typ EventTags
	typ = make(EventTags)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EventTags
	typ2 = make(EventTags)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestException_EncodeDecode(t *testing.T) {
	var typ Exception
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Exception
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestFrame_EncodeDecode(t *testing.T) {
	var typ Frame
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Frame
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestFrameVars_EncodeDecode(t *testing.T) {
	var typ FrameVars
	typ = make(FrameVars)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 FrameVars
	typ2 = make(FrameVars)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestLevel_EncodeDecode(t *testing.T) {
	var typ Level
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Level
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestMachException_EncodeDecode(t *testing.T) {
	var typ MachException
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 MachException
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestMechanism_EncodeDecode(t *testing.T) {
	var typ Mechanism
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Mechanism
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestMechanismData_EncodeDecode(t *testing.T) {
	var typ MechanismData
	typ = make(MechanismData)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 MechanismData
	typ2 = make(MechanismData)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestMechanismMeta_EncodeDecode(t *testing.T) {
	var typ MechanismMeta
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 MechanismMeta
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNSError_EncodeDecode(t *testing.T) {
	var typ NSError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NSError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRequest_EncodeDecode(t *testing.T) {
	var typ Request
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Request
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRequestEnv_EncodeDecode(t *testing.T) {
	var typ RequestEnv
	typ = make(RequestEnv)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RequestEnv
	typ2 = make(RequestEnv)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRequestHeaders_EncodeDecode(t *testing.T) {
	var typ RequestHeaders
	typ = make(RequestHeaders)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RequestHeaders
	typ2 = make(RequestHeaders)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSdkInfo_EncodeDecode(t *testing.T) {
	var typ SdkInfo
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SdkInfo
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSdkPackage_EncodeDecode(t *testing.T) {
	var typ SdkPackage
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SdkPackage
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSignal_EncodeDecode(t *testing.T) {
	var typ Signal
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Signal
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSpan_EncodeDecode(t *testing.T) {
	var typ Span
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Span
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSpanData_EncodeDecode(t *testing.T) {
	var typ SpanData
	typ = make(SpanData)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SpanData
	typ2 = make(SpanData)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSpanID_EncodeDecode(t *testing.T) {
	var typ SpanID
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SpanID
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSpanTags_EncodeDecode(t *testing.T) {
	var typ SpanTags
	typ = make(SpanTags)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SpanTags
	typ2 = make(SpanTags)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestStacktrace_EncodeDecode(t *testing.T) {
	var typ Stacktrace
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Stacktrace
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestStacktraceRegisters_EncodeDecode(t *testing.T) {
	var typ StacktraceRegisters
	typ = make(StacktraceRegisters)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 StacktraceRegisters
	typ2 = make(StacktraceRegisters)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestThread_EncodeDecode(t *testing.T) {
	var typ Thread
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Thread
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestThreadHeldLocks_EncodeDecode(t *testing.T) {
	var typ ThreadHeldLocks
	typ = make(ThreadHeldLocks)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ThreadHeldLocks
	typ2 = make(ThreadHeldLocks)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTimestamp_EncodeDecode(t *testing.T) {
	var typ Timestamp
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Timestamp
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTraceID_EncodeDecode(t *testing.T) {
	var typ TraceID
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TraceID
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTransactionInfo_EncodeDecode(t *testing.T) {
	var typ TransactionInfo
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TransactionInfo
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTransactionSource_EncodeDecode(t *testing.T) {
	var typ TransactionSource
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TransactionSource
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUser_EncodeDecode(t *testing.T) {
	var typ User
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 User
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUserAdditional_EncodeDecode(t *testing.T) {
	var typ UserAdditional
	typ = make(UserAdditional)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UserAdditional
	typ2 = make(UserAdditional)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
