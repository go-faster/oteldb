// Code generated by ogen, DO NOT EDIT.

package sentryapi

import (
	"math/bits"
	"strconv"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/validate"
)

// Encode implements json.Marshaler.
func (s *Breadcrumb) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Breadcrumb) encodeFields(e *jx.Encoder) {
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.Category.Set {
			e.FieldStart("category")
			s.Category.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
	{
		if s.Level.Set {
			e.FieldStart("level")
			s.Level.Encode(e)
		}
	}
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
}

var jsonFieldsNameOfBreadcrumb = [6]string{
	0: "type",
	1: "category",
	2: "message",
	3: "data",
	4: "level",
	5: "timestamp",
}

// Decode decodes Breadcrumb from json.
func (s *Breadcrumb) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Breadcrumb to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "category":
			if err := func() error {
				s.Category.Reset()
				if err := s.Category.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"category\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "level":
			if err := func() error {
				s.Level.Reset()
				if err := s.Level.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Breadcrumb")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Breadcrumb) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Breadcrumb) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s BreadcrumbData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s BreadcrumbData) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes BreadcrumbData from json.
func (s *BreadcrumbData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BreadcrumbData to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BreadcrumbData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BreadcrumbData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BreadcrumbData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s Context) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s Context) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes Context from json.
func (s *Context) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Context to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Context")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Context) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Context) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DebugImage) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DebugImage) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		if s.ImageAddr.Set {
			e.FieldStart("image_addr")
			s.ImageAddr.Encode(e)
		}
	}
	{
		if s.ImageSize.Set {
			e.FieldStart("image_size")
			s.ImageSize.Encode(e)
		}
	}
	{
		if s.DebugID.Set {
			e.FieldStart("debug_id")
			s.DebugID.Encode(e)
		}
	}
	{
		if s.DebugFile.Set {
			e.FieldStart("debug_file")
			s.DebugFile.Encode(e)
		}
	}
	{
		if s.CodeID.Set {
			e.FieldStart("code_id")
			s.CodeID.Encode(e)
		}
	}
	{
		if s.CodeFile.Set {
			e.FieldStart("code_file")
			s.CodeFile.Encode(e)
		}
	}
	{
		if s.ImageVmaddr.Set {
			e.FieldStart("image_vmaddr")
			s.ImageVmaddr.Encode(e)
		}
	}
	{
		if s.Arch.Set {
			e.FieldStart("arch")
			s.Arch.Encode(e)
		}
	}
	{
		if s.UUID.Set {
			e.FieldStart("uuid")
			s.UUID.Encode(e)
		}
	}
}

var jsonFieldsNameOfDebugImage = [10]string{
	0: "type",
	1: "image_addr",
	2: "image_size",
	3: "debug_id",
	4: "debug_file",
	5: "code_id",
	6: "code_file",
	7: "image_vmaddr",
	8: "arch",
	9: "uuid",
}

// Decode decodes DebugImage from json.
func (s *DebugImage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DebugImage to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "image_addr":
			if err := func() error {
				s.ImageAddr.Reset()
				if err := s.ImageAddr.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"image_addr\"")
			}
		case "image_size":
			if err := func() error {
				s.ImageSize.Reset()
				if err := s.ImageSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"image_size\"")
			}
		case "debug_id":
			if err := func() error {
				s.DebugID.Reset()
				if err := s.DebugID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"debug_id\"")
			}
		case "debug_file":
			if err := func() error {
				s.DebugFile.Reset()
				if err := s.DebugFile.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"debug_file\"")
			}
		case "code_id":
			if err := func() error {
				s.CodeID.Reset()
				if err := s.CodeID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code_id\"")
			}
		case "code_file":
			if err := func() error {
				s.CodeFile.Reset()
				if err := s.CodeFile.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code_file\"")
			}
		case "image_vmaddr":
			if err := func() error {
				s.ImageVmaddr.Reset()
				if err := s.ImageVmaddr.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"image_vmaddr\"")
			}
		case "arch":
			if err := func() error {
				s.Arch.Reset()
				if err := s.Arch.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"arch\"")
			}
		case "uuid":
			if err := func() error {
				s.UUID.Reset()
				if err := s.UUID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DebugImage")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000001,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDebugImage) {
					name = jsonFieldsNameOfDebugImage[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DebugImage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DebugImage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DebugMeta) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DebugMeta) encodeFields(e *jx.Encoder) {
	{
		if s.SdkInfo.Set {
			e.FieldStart("sdk_info")
			s.SdkInfo.Encode(e)
		}
	}
	{
		if s.Images.Set {
			e.FieldStart("images")
			s.Images.Encode(e)
		}
	}
}

var jsonFieldsNameOfDebugMeta = [2]string{
	0: "sdk_info",
	1: "images",
}

// Decode decodes DebugMeta from json.
func (s *DebugMeta) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DebugMeta to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sdk_info":
			if err := func() error {
				s.SdkInfo.Reset()
				if err := s.SdkInfo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sdk_info\"")
			}
		case "images":
			if err := func() error {
				s.Images.Reset()
				if err := s.Images.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"images\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DebugMeta")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DebugMeta) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DebugMeta) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DebugMetaSdkInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DebugMetaSdkInfo) encodeFields(e *jx.Encoder) {
	{
		if s.SdkName.Set {
			e.FieldStart("sdk_name")
			s.SdkName.Encode(e)
		}
	}
	{
		if s.VersionMajor.Set {
			e.FieldStart("version_major")
			s.VersionMajor.Encode(e)
		}
	}
	{
		if s.VersionMinor.Set {
			e.FieldStart("version_minor")
			s.VersionMinor.Encode(e)
		}
	}
	{
		if s.VersionPatchlevel.Set {
			e.FieldStart("version_patchlevel")
			s.VersionPatchlevel.Encode(e)
		}
	}
}

var jsonFieldsNameOfDebugMetaSdkInfo = [4]string{
	0: "sdk_name",
	1: "version_major",
	2: "version_minor",
	3: "version_patchlevel",
}

// Decode decodes DebugMetaSdkInfo from json.
func (s *DebugMetaSdkInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DebugMetaSdkInfo to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sdk_name":
			if err := func() error {
				s.SdkName.Reset()
				if err := s.SdkName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sdk_name\"")
			}
		case "version_major":
			if err := func() error {
				s.VersionMajor.Reset()
				if err := s.VersionMajor.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version_major\"")
			}
		case "version_minor":
			if err := func() error {
				s.VersionMinor.Reset()
				if err := s.VersionMinor.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version_minor\"")
			}
		case "version_patchlevel":
			if err := func() error {
				s.VersionPatchlevel.Reset()
				if err := s.VersionPatchlevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version_patchlevel\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DebugMetaSdkInfo")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DebugMetaSdkInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DebugMetaSdkInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Errno) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Errno) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("number")
		e.Int(s.Number)
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
}

var jsonFieldsNameOfErrno = [2]string{
	0: "number",
	1: "name",
}

// Decode decodes Errno from json.
func (s *Errno) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Errno to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "number":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Number = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"number\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Errno")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfErrno) {
					name = jsonFieldsNameOfErrno[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Errno) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Errno) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Error as json.
func (s Error) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes Error from json.
func (s *Error) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Error to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = Error(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Error) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Error) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Event) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Event) encodeFields(e *jx.Encoder) {
	{
		if s.Breadcrumbs != nil {
			e.FieldStart("breadcrumbs")
			e.ArrStart()
			for _, elem := range s.Breadcrumbs {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Contexts.Set {
			e.FieldStart("contexts")
			s.Contexts.Encode(e)
		}
	}
	{
		if s.Dist.Set {
			e.FieldStart("dist")
			s.Dist.Encode(e)
		}
	}
	{
		if s.Environment.Set {
			e.FieldStart("environment")
			s.Environment.Encode(e)
		}
	}
	{
		e.FieldStart("event_id")
		s.EventID.Encode(e)
	}
	{
		if s.Extra.Set {
			e.FieldStart("extra")
			s.Extra.Encode(e)
		}
	}
	{
		if s.Fingerprint != nil {
			e.FieldStart("fingerprint")
			e.ArrStart()
			for _, elem := range s.Fingerprint {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Level.Set {
			e.FieldStart("level")
			s.Level.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		e.FieldStart("platform")
		e.Str(s.Platform)
	}
	{
		if s.Release.Set {
			e.FieldStart("release")
			s.Release.Encode(e)
		}
	}
	{
		if s.Sdk.Set {
			e.FieldStart("sdk")
			s.Sdk.Encode(e)
		}
	}
	{
		if s.ServerName.Set {
			e.FieldStart("server_name")
			s.ServerName.Encode(e)
		}
	}
	{
		if s.Threads != nil {
			e.FieldStart("threads")
			e.ArrStart()
			for _, elem := range s.Threads {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Tags.Set {
			e.FieldStart("tags")
			s.Tags.Encode(e)
		}
	}
	{
		e.FieldStart("timestamp")
		s.Timestamp.Encode(e)
	}
	{
		if s.Transaction.Set {
			e.FieldStart("transaction")
			s.Transaction.Encode(e)
		}
	}
	{
		if s.User.Set {
			e.FieldStart("user")
			s.User.Encode(e)
		}
	}
	{
		if s.Logger.Set {
			e.FieldStart("logger")
			s.Logger.Encode(e)
		}
	}
	{
		if s.Modules.Set {
			e.FieldStart("modules")
			s.Modules.Encode(e)
		}
	}
	{
		if s.Request.Set {
			e.FieldStart("request")
			s.Request.Encode(e)
		}
	}
	{
		if s.Exception != nil {
			e.FieldStart("exception")
			e.ArrStart()
			for _, elem := range s.Exception {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.DebugMeta.Set {
			e.FieldStart("debug_meta")
			s.DebugMeta.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.StartTimestamp.Set {
			e.FieldStart("start_timestamp")
			s.StartTimestamp.Encode(e)
		}
	}
	{
		if s.Spans != nil {
			e.FieldStart("spans")
			e.ArrStart()
			for _, elem := range s.Spans {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.TransactionInfo.Set {
			e.FieldStart("transaction_info")
			s.TransactionInfo.Encode(e)
		}
	}
}

var jsonFieldsNameOfEvent = [27]string{
	0:  "breadcrumbs",
	1:  "contexts",
	2:  "dist",
	3:  "environment",
	4:  "event_id",
	5:  "extra",
	6:  "fingerprint",
	7:  "level",
	8:  "message",
	9:  "platform",
	10: "release",
	11: "sdk",
	12: "server_name",
	13: "threads",
	14: "tags",
	15: "timestamp",
	16: "transaction",
	17: "user",
	18: "logger",
	19: "modules",
	20: "request",
	21: "exception",
	22: "debug_meta",
	23: "type",
	24: "start_timestamp",
	25: "spans",
	26: "transaction_info",
}

// Decode decodes Event from json.
func (s *Event) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Event to nil")
	}
	var requiredBitSet [4]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "breadcrumbs":
			if err := func() error {
				s.Breadcrumbs = make([]Breadcrumb, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Breadcrumb
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Breadcrumbs = append(s.Breadcrumbs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"breadcrumbs\"")
			}
		case "contexts":
			if err := func() error {
				s.Contexts.Reset()
				if err := s.Contexts.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contexts\"")
			}
		case "dist":
			if err := func() error {
				s.Dist.Reset()
				if err := s.Dist.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dist\"")
			}
		case "environment":
			if err := func() error {
				s.Environment.Reset()
				if err := s.Environment.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"environment\"")
			}
		case "event_id":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.EventID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"event_id\"")
			}
		case "extra":
			if err := func() error {
				s.Extra.Reset()
				if err := s.Extra.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"extra\"")
			}
		case "fingerprint":
			if err := func() error {
				s.Fingerprint = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Fingerprint = append(s.Fingerprint, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fingerprint\"")
			}
		case "level":
			if err := func() error {
				s.Level.Reset()
				if err := s.Level.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"level\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "platform":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Platform = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"platform\"")
			}
		case "release":
			if err := func() error {
				s.Release.Reset()
				if err := s.Release.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"release\"")
			}
		case "sdk":
			if err := func() error {
				s.Sdk.Reset()
				if err := s.Sdk.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sdk\"")
			}
		case "server_name":
			if err := func() error {
				s.ServerName.Reset()
				if err := s.ServerName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"server_name\"")
			}
		case "threads":
			if err := func() error {
				s.Threads = make([]Thread, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Thread
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Threads = append(s.Threads, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"threads\"")
			}
		case "tags":
			if err := func() error {
				s.Tags.Reset()
				if err := s.Tags.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		case "timestamp":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "transaction":
			if err := func() error {
				s.Transaction.Reset()
				if err := s.Transaction.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"transaction\"")
			}
		case "user":
			if err := func() error {
				s.User.Reset()
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "logger":
			if err := func() error {
				s.Logger.Reset()
				if err := s.Logger.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"logger\"")
			}
		case "modules":
			if err := func() error {
				s.Modules.Reset()
				if err := s.Modules.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"modules\"")
			}
		case "request":
			if err := func() error {
				s.Request.Reset()
				if err := s.Request.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"request\"")
			}
		case "exception":
			if err := func() error {
				s.Exception = make([]Exception, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Exception
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Exception = append(s.Exception, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exception\"")
			}
		case "debug_meta":
			if err := func() error {
				s.DebugMeta.Reset()
				if err := s.DebugMeta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"debug_meta\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "start_timestamp":
			if err := func() error {
				s.StartTimestamp.Reset()
				if err := s.StartTimestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start_timestamp\"")
			}
		case "spans":
			if err := func() error {
				s.Spans = make([]Span, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Span
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Spans = append(s.Spans, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spans\"")
			}
		case "transaction_info":
			if err := func() error {
				s.TransactionInfo.Reset()
				if err := s.TransactionInfo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"transaction_info\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Event")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b00010000,
		0b10000010,
		0b00000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEvent) {
					name = jsonFieldsNameOfEvent[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Event) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Event) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s EventContexts) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s EventContexts) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes EventContexts from json.
func (s *EventContexts) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EventContexts to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem Context
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EventContexts")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EventContexts) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EventContexts) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s EventExtra) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s EventExtra) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes EventExtra from json.
func (s *EventExtra) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EventExtra to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EventExtra")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EventExtra) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EventExtra) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EventID as json.
func (s EventID) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes EventID from json.
func (s *EventID) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EventID to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = EventID(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EventID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EventID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s EventModules) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s EventModules) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes EventModules from json.
func (s *EventModules) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EventModules to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EventModules")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EventModules) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EventModules) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s EventTags) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s EventTags) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes EventTags from json.
func (s *EventTags) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EventTags to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EventTags")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EventTags) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EventTags) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Exception) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Exception) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("value")
		e.Str(s.Value)
	}
	{
		if s.Module.Set {
			e.FieldStart("module")
			s.Module.Encode(e)
		}
	}
	{
		if s.ThreadID.Set {
			e.FieldStart("thread_id")
			s.ThreadID.Encode(e)
		}
	}
	{
		if s.Stacktrace.Set {
			e.FieldStart("stacktrace")
			s.Stacktrace.Encode(e)
		}
	}
	{
		if s.Mechanism.Set {
			e.FieldStart("mechanism")
			s.Mechanism.Encode(e)
		}
	}
}

var jsonFieldsNameOfException = [6]string{
	0: "type",
	1: "value",
	2: "module",
	3: "thread_id",
	4: "stacktrace",
	5: "mechanism",
}

// Decode decodes Exception from json.
func (s *Exception) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Exception to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Value = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		case "module":
			if err := func() error {
				s.Module.Reset()
				if err := s.Module.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"module\"")
			}
		case "thread_id":
			if err := func() error {
				s.ThreadID.Reset()
				if err := s.ThreadID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thread_id\"")
			}
		case "stacktrace":
			if err := func() error {
				s.Stacktrace.Reset()
				if err := s.Stacktrace.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stacktrace\"")
			}
		case "mechanism":
			if err := func() error {
				s.Mechanism.Reset()
				if err := s.Mechanism.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mechanism\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Exception")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfException) {
					name = jsonFieldsNameOfException[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Exception) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Exception) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Frame) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Frame) encodeFields(e *jx.Encoder) {
	{
		if s.Function.Set {
			e.FieldStart("function")
			s.Function.Encode(e)
		}
	}
	{
		if s.Symbol.Set {
			e.FieldStart("symbol")
			s.Symbol.Encode(e)
		}
	}
	{
		if s.Module.Set {
			e.FieldStart("module")
			s.Module.Encode(e)
		}
	}
	{
		if s.Filename.Set {
			e.FieldStart("filename")
			s.Filename.Encode(e)
		}
	}
	{
		if s.AbsPath.Set {
			e.FieldStart("abs_path")
			s.AbsPath.Encode(e)
		}
	}
	{
		if s.Lineno.Set {
			e.FieldStart("lineno")
			s.Lineno.Encode(e)
		}
	}
	{
		if s.Colno.Set {
			e.FieldStart("colno")
			s.Colno.Encode(e)
		}
	}
	{
		if s.PreContext != nil {
			e.FieldStart("pre_context")
			e.ArrStart()
			for _, elem := range s.PreContext {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ContextLine.Set {
			e.FieldStart("context_line")
			s.ContextLine.Encode(e)
		}
	}
	{
		if s.PostContext != nil {
			e.FieldStart("post_context")
			e.ArrStart()
			for _, elem := range s.PostContext {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.InApp.Set {
			e.FieldStart("in_app")
			s.InApp.Encode(e)
		}
	}
	{
		if s.Vars.Set {
			e.FieldStart("vars")
			s.Vars.Encode(e)
		}
	}
	{
		if s.Package.Set {
			e.FieldStart("package")
			s.Package.Encode(e)
		}
	}
	{
		if s.InstructionAddr.Set {
			e.FieldStart("instruction_addr")
			s.InstructionAddr.Encode(e)
		}
	}
	{
		if s.AddrMode.Set {
			e.FieldStart("addr_mode")
			s.AddrMode.Encode(e)
		}
	}
	{
		if s.SymbolAddr.Set {
			e.FieldStart("symbol_addr")
			s.SymbolAddr.Encode(e)
		}
	}
	{
		if s.ImageAddr.Set {
			e.FieldStart("image_addr")
			s.ImageAddr.Encode(e)
		}
	}
	{
		if s.Platform.Set {
			e.FieldStart("platform")
			s.Platform.Encode(e)
		}
	}
	{
		if s.StackStart.Set {
			e.FieldStart("stack_start")
			s.StackStart.Encode(e)
		}
	}
}

var jsonFieldsNameOfFrame = [19]string{
	0:  "function",
	1:  "symbol",
	2:  "module",
	3:  "filename",
	4:  "abs_path",
	5:  "lineno",
	6:  "colno",
	7:  "pre_context",
	8:  "context_line",
	9:  "post_context",
	10: "in_app",
	11: "vars",
	12: "package",
	13: "instruction_addr",
	14: "addr_mode",
	15: "symbol_addr",
	16: "image_addr",
	17: "platform",
	18: "stack_start",
}

// Decode decodes Frame from json.
func (s *Frame) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Frame to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "function":
			if err := func() error {
				s.Function.Reset()
				if err := s.Function.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"function\"")
			}
		case "symbol":
			if err := func() error {
				s.Symbol.Reset()
				if err := s.Symbol.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"symbol\"")
			}
		case "module":
			if err := func() error {
				s.Module.Reset()
				if err := s.Module.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"module\"")
			}
		case "filename":
			if err := func() error {
				s.Filename.Reset()
				if err := s.Filename.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"filename\"")
			}
		case "abs_path":
			if err := func() error {
				s.AbsPath.Reset()
				if err := s.AbsPath.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"abs_path\"")
			}
		case "lineno":
			if err := func() error {
				s.Lineno.Reset()
				if err := s.Lineno.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lineno\"")
			}
		case "colno":
			if err := func() error {
				s.Colno.Reset()
				if err := s.Colno.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"colno\"")
			}
		case "pre_context":
			if err := func() error {
				s.PreContext = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.PreContext = append(s.PreContext, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pre_context\"")
			}
		case "context_line":
			if err := func() error {
				s.ContextLine.Reset()
				if err := s.ContextLine.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"context_line\"")
			}
		case "post_context":
			if err := func() error {
				s.PostContext = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.PostContext = append(s.PostContext, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"post_context\"")
			}
		case "in_app":
			if err := func() error {
				s.InApp.Reset()
				if err := s.InApp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"in_app\"")
			}
		case "vars":
			if err := func() error {
				s.Vars.Reset()
				if err := s.Vars.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vars\"")
			}
		case "package":
			if err := func() error {
				s.Package.Reset()
				if err := s.Package.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"package\"")
			}
		case "instruction_addr":
			if err := func() error {
				s.InstructionAddr.Reset()
				if err := s.InstructionAddr.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instruction_addr\"")
			}
		case "addr_mode":
			if err := func() error {
				s.AddrMode.Reset()
				if err := s.AddrMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"addr_mode\"")
			}
		case "symbol_addr":
			if err := func() error {
				s.SymbolAddr.Reset()
				if err := s.SymbolAddr.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"symbol_addr\"")
			}
		case "image_addr":
			if err := func() error {
				s.ImageAddr.Reset()
				if err := s.ImageAddr.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"image_addr\"")
			}
		case "platform":
			if err := func() error {
				s.Platform.Reset()
				if err := s.Platform.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"platform\"")
			}
		case "stack_start":
			if err := func() error {
				s.StackStart.Reset()
				if err := s.StackStart.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stack_start\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Frame")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Frame) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Frame) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s FrameVars) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s FrameVars) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes FrameVars from json.
func (s *FrameVars) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FrameVars to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FrameVars")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s FrameVars) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FrameVars) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Level as json.
func (s Level) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes Level from json.
func (s *Level) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Level to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = Level(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Level) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Level) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MachException) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MachException) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("exception")
		e.Int(s.Exception)
	}
	{
		e.FieldStart("code")
		e.Int(s.Code)
	}
	{
		e.FieldStart("subcode")
		e.Int(s.Subcode)
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
}

var jsonFieldsNameOfMachException = [4]string{
	0: "exception",
	1: "code",
	2: "subcode",
	3: "name",
}

// Decode decodes MachException from json.
func (s *MachException) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MachException to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "exception":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Exception = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exception\"")
			}
		case "code":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Code = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "subcode":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Subcode = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subcode\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MachException")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMachException) {
					name = jsonFieldsNameOfMachException[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MachException) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MachException) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Mechanism) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Mechanism) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.HelpLink.Set {
			e.FieldStart("help_link")
			s.HelpLink.Encode(e)
		}
	}
	{
		if s.Handled.Set {
			e.FieldStart("handled")
			s.Handled.Encode(e)
		}
	}
	{
		if s.Synthetic.Set {
			e.FieldStart("synthetic")
			s.Synthetic.Encode(e)
		}
	}
	{
		if s.Meta.Set {
			e.FieldStart("meta")
			s.Meta.Encode(e)
		}
	}
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfMechanism = [7]string{
	0: "type",
	1: "description",
	2: "help_link",
	3: "handled",
	4: "synthetic",
	5: "meta",
	6: "data",
}

// Decode decodes Mechanism from json.
func (s *Mechanism) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Mechanism to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "help_link":
			if err := func() error {
				s.HelpLink.Reset()
				if err := s.HelpLink.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"help_link\"")
			}
		case "handled":
			if err := func() error {
				s.Handled.Reset()
				if err := s.Handled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"handled\"")
			}
		case "synthetic":
			if err := func() error {
				s.Synthetic.Reset()
				if err := s.Synthetic.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"synthetic\"")
			}
		case "meta":
			if err := func() error {
				s.Meta.Reset()
				if err := s.Meta.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"meta\"")
			}
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Mechanism")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfMechanism) {
					name = jsonFieldsNameOfMechanism[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Mechanism) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Mechanism) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s MechanismData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s MechanismData) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes MechanismData from json.
func (s *MechanismData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MechanismData to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MechanismData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s MechanismData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MechanismData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *MechanismMeta) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *MechanismMeta) encodeFields(e *jx.Encoder) {
	{
		if s.Signal.Set {
			e.FieldStart("signal")
			s.Signal.Encode(e)
		}
	}
	{
		if s.MachException.Set {
			e.FieldStart("mach_exception")
			s.MachException.Encode(e)
		}
	}
	{
		if s.NsError.Set {
			e.FieldStart("ns_error")
			s.NsError.Encode(e)
		}
	}
	{
		if s.Errno.Set {
			e.FieldStart("errno")
			s.Errno.Encode(e)
		}
	}
}

var jsonFieldsNameOfMechanismMeta = [4]string{
	0: "signal",
	1: "mach_exception",
	2: "ns_error",
	3: "errno",
}

// Decode decodes MechanismMeta from json.
func (s *MechanismMeta) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode MechanismMeta to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "signal":
			if err := func() error {
				s.Signal.Reset()
				if err := s.Signal.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"signal\"")
			}
		case "mach_exception":
			if err := func() error {
				s.MachException.Reset()
				if err := s.MachException.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mach_exception\"")
			}
		case "ns_error":
			if err := func() error {
				s.NsError.Reset()
				if err := s.NsError.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ns_error\"")
			}
		case "errno":
			if err := func() error {
				s.Errno.Reset()
				if err := s.Errno.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errno\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode MechanismMeta")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *MechanismMeta) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *MechanismMeta) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NSError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NSError) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("code")
		e.Int(s.Code)
	}
	{
		if s.Domain.Set {
			e.FieldStart("domain")
			s.Domain.Encode(e)
		}
	}
}

var jsonFieldsNameOfNSError = [2]string{
	0: "code",
	1: "domain",
}

// Decode decodes NSError from json.
func (s *NSError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NSError to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "code":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Code = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "domain":
			if err := func() error {
				s.Domain.Reset()
				if err := s.Domain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domain\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NSError")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNSError) {
					name = jsonFieldsNameOfNSError[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NSError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NSError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	o.Set = true
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BreadcrumbData as json.
func (o OptBreadcrumbData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes BreadcrumbData from json.
func (o *OptBreadcrumbData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBreadcrumbData to nil")
	}
	o.Set = true
	o.Value = make(BreadcrumbData)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBreadcrumbData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBreadcrumbData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DebugImage as json.
func (o OptDebugImage) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DebugImage from json.
func (o *OptDebugImage) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDebugImage to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDebugImage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDebugImage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DebugMeta as json.
func (o OptDebugMeta) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DebugMeta from json.
func (o *OptDebugMeta) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDebugMeta to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDebugMeta) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDebugMeta) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DebugMetaSdkInfo as json.
func (o OptDebugMetaSdkInfo) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DebugMetaSdkInfo from json.
func (o *OptDebugMetaSdkInfo) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDebugMetaSdkInfo to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDebugMetaSdkInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDebugMetaSdkInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Errno as json.
func (o OptErrno) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Errno from json.
func (o *OptErrno) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptErrno to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptErrno) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptErrno) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EventContexts as json.
func (o OptEventContexts) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes EventContexts from json.
func (o *OptEventContexts) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEventContexts to nil")
	}
	o.Set = true
	o.Value = make(EventContexts)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEventContexts) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEventContexts) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EventExtra as json.
func (o OptEventExtra) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes EventExtra from json.
func (o *OptEventExtra) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEventExtra to nil")
	}
	o.Set = true
	o.Value = make(EventExtra)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEventExtra) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEventExtra) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EventModules as json.
func (o OptEventModules) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes EventModules from json.
func (o *OptEventModules) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEventModules to nil")
	}
	o.Set = true
	o.Value = make(EventModules)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEventModules) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEventModules) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EventTags as json.
func (o OptEventTags) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes EventTags from json.
func (o *OptEventTags) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEventTags to nil")
	}
	o.Set = true
	o.Value = make(EventTags)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEventTags) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEventTags) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes FrameVars as json.
func (o OptFrameVars) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes FrameVars from json.
func (o *OptFrameVars) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFrameVars to nil")
	}
	o.Set = true
	o.Value = make(FrameVars)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFrameVars) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFrameVars) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt to nil")
	}
	o.Set = true
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Level as json.
func (o OptLevel) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Level from json.
func (o *OptLevel) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptLevel to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptLevel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptLevel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MachException as json.
func (o OptMachException) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes MachException from json.
func (o *OptMachException) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMachException to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptMachException) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptMachException) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Mechanism as json.
func (o OptMechanism) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Mechanism from json.
func (o *OptMechanism) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMechanism to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptMechanism) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptMechanism) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MechanismData as json.
func (o OptMechanismData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes MechanismData from json.
func (o *OptMechanismData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMechanismData to nil")
	}
	o.Set = true
	o.Value = make(MechanismData)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptMechanismData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptMechanismData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes MechanismMeta as json.
func (o OptMechanismMeta) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes MechanismMeta from json.
func (o *OptMechanismMeta) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptMechanismMeta to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptMechanismMeta) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptMechanismMeta) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NSError as json.
func (o OptNSError) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NSError from json.
func (o *OptNSError) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNSError to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNSError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNSError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Request as json.
func (o OptRequest) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Request from json.
func (o *OptRequest) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRequest to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RequestEnv as json.
func (o OptRequestEnv) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RequestEnv from json.
func (o *OptRequestEnv) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRequestEnv to nil")
	}
	o.Set = true
	o.Value = make(RequestEnv)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRequestEnv) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRequestEnv) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RequestHeaders as json.
func (o OptRequestHeaders) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RequestHeaders from json.
func (o *OptRequestHeaders) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRequestHeaders to nil")
	}
	o.Set = true
	o.Value = make(RequestHeaders)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRequestHeaders) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRequestHeaders) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SdkInfo as json.
func (o OptSdkInfo) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SdkInfo from json.
func (o *OptSdkInfo) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSdkInfo to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSdkInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSdkInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Signal as json.
func (o OptSignal) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Signal from json.
func (o *OptSignal) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSignal to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSignal) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSignal) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SpanData as json.
func (o OptSpanData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SpanData from json.
func (o *OptSpanData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSpanData to nil")
	}
	o.Set = true
	o.Value = make(SpanData)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSpanData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSpanData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SpanID as json.
func (o OptSpanID) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SpanID from json.
func (o *OptSpanID) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSpanID to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSpanID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSpanID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SpanTags as json.
func (o OptSpanTags) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SpanTags from json.
func (o *OptSpanTags) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSpanTags to nil")
	}
	o.Set = true
	o.Value = make(SpanTags)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSpanTags) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSpanTags) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Stacktrace as json.
func (o OptStacktrace) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Stacktrace from json.
func (o *OptStacktrace) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptStacktrace to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptStacktrace) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptStacktrace) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StacktraceRegisters as json.
func (o OptStacktraceRegisters) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes StacktraceRegisters from json.
func (o *OptStacktraceRegisters) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptStacktraceRegisters to nil")
	}
	o.Set = true
	o.Value = make(StacktraceRegisters)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptStacktraceRegisters) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptStacktraceRegisters) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ThreadHeldLocks as json.
func (o OptThreadHeldLocks) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ThreadHeldLocks from json.
func (o *OptThreadHeldLocks) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptThreadHeldLocks to nil")
	}
	o.Set = true
	o.Value = make(ThreadHeldLocks)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptThreadHeldLocks) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptThreadHeldLocks) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Timestamp as json.
func (o OptTimestamp) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Timestamp from json.
func (o *OptTimestamp) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTimestamp to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTimestamp) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTimestamp) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TransactionInfo as json.
func (o OptTransactionInfo) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TransactionInfo from json.
func (o *OptTransactionInfo) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTransactionInfo to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTransactionInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTransactionInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes User as json.
func (o OptUser) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes User from json.
func (o *OptUser) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUser to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUser) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUser) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Request) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Request) encodeFields(e *jx.Encoder) {
	{
		if s.URL.Set {
			e.FieldStart("url")
			s.URL.Encode(e)
		}
	}
	{
		if s.Method.Set {
			e.FieldStart("method")
			s.Method.Encode(e)
		}
	}
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
	{
		if s.QueryString.Set {
			e.FieldStart("query_string")
			s.QueryString.Encode(e)
		}
	}
	{
		if s.Cookies.Set {
			e.FieldStart("cookies")
			s.Cookies.Encode(e)
		}
	}
	{
		if s.Headers.Set {
			e.FieldStart("headers")
			s.Headers.Encode(e)
		}
	}
	{
		if s.Env.Set {
			e.FieldStart("env")
			s.Env.Encode(e)
		}
	}
}

var jsonFieldsNameOfRequest = [7]string{
	0: "url",
	1: "method",
	2: "data",
	3: "query_string",
	4: "cookies",
	5: "headers",
	6: "env",
}

// Decode decodes Request from json.
func (s *Request) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Request to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "method":
			if err := func() error {
				s.Method.Reset()
				if err := s.Method.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"method\"")
			}
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "query_string":
			if err := func() error {
				s.QueryString.Reset()
				if err := s.QueryString.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"query_string\"")
			}
		case "cookies":
			if err := func() error {
				s.Cookies.Reset()
				if err := s.Cookies.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cookies\"")
			}
		case "headers":
			if err := func() error {
				s.Headers.Reset()
				if err := s.Headers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"headers\"")
			}
		case "env":
			if err := func() error {
				s.Env.Reset()
				if err := s.Env.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"env\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Request")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Request) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Request) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s RequestEnv) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s RequestEnv) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes RequestEnv from json.
func (s *RequestEnv) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RequestEnv to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RequestEnv")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RequestEnv) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RequestEnv) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s RequestHeaders) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s RequestHeaders) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes RequestHeaders from json.
func (s *RequestHeaders) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RequestHeaders to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RequestHeaders")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RequestHeaders) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RequestHeaders) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SdkInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SdkInfo) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		e.FieldStart("version")
		e.Str(s.Version)
	}
	{
		if s.Integrations != nil {
			e.FieldStart("integrations")
			e.ArrStart()
			for _, elem := range s.Integrations {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Packages != nil {
			e.FieldStart("packages")
			e.ArrStart()
			for _, elem := range s.Packages {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfSdkInfo = [4]string{
	0: "name",
	1: "version",
	2: "integrations",
	3: "packages",
}

// Decode decodes SdkInfo from json.
func (s *SdkInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SdkInfo to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "version":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Version = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "integrations":
			if err := func() error {
				s.Integrations = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Integrations = append(s.Integrations, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"integrations\"")
			}
		case "packages":
			if err := func() error {
				s.Packages = make([]SdkPackage, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SdkPackage
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Packages = append(s.Packages, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"packages\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SdkInfo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSdkInfo) {
					name = jsonFieldsNameOfSdkInfo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SdkInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SdkInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SdkPackage) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SdkPackage) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Version.Set {
			e.FieldStart("version")
			s.Version.Encode(e)
		}
	}
}

var jsonFieldsNameOfSdkPackage = [2]string{
	0: "name",
	1: "version",
}

// Decode decodes SdkPackage from json.
func (s *SdkPackage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SdkPackage to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SdkPackage")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SdkPackage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SdkPackage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Signal) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Signal) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("number")
		e.Int(s.Number)
	}
	{
		if s.Code.Set {
			e.FieldStart("code")
			s.Code.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.CodeName.Set {
			e.FieldStart("code_name")
			s.CodeName.Encode(e)
		}
	}
}

var jsonFieldsNameOfSignal = [4]string{
	0: "number",
	1: "code",
	2: "name",
	3: "code_name",
}

// Decode decodes Signal from json.
func (s *Signal) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Signal to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "number":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Number = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"number\"")
			}
		case "code":
			if err := func() error {
				s.Code.Reset()
				if err := s.Code.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "code_name":
			if err := func() error {
				s.CodeName.Reset()
				if err := s.CodeName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code_name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Signal")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSignal) {
					name = jsonFieldsNameOfSignal[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Signal) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Signal) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Span) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Span) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("trace_id")
		s.TraceID.Encode(e)
	}
	{
		e.FieldStart("span_id")
		s.SpanID.Encode(e)
	}
	{
		if s.ParentSpanID.Set {
			e.FieldStart("parent_span_id")
			s.ParentSpanID.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Op.Set {
			e.FieldStart("op")
			s.Op.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.Tags.Set {
			e.FieldStart("tags")
			s.Tags.Encode(e)
		}
	}
	{
		e.FieldStart("start_timestamp")
		s.StartTimestamp.Encode(e)
	}
	{
		e.FieldStart("timestamp")
		s.Timestamp.Encode(e)
	}
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
}

var jsonFieldsNameOfSpan = [11]string{
	0:  "trace_id",
	1:  "span_id",
	2:  "parent_span_id",
	3:  "name",
	4:  "op",
	5:  "description",
	6:  "status",
	7:  "tags",
	8:  "start_timestamp",
	9:  "timestamp",
	10: "data",
}

// Decode decodes Span from json.
func (s *Span) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Span to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "trace_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.TraceID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trace_id\"")
			}
		case "span_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.SpanID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"span_id\"")
			}
		case "parent_span_id":
			if err := func() error {
				s.ParentSpanID.Reset()
				if err := s.ParentSpanID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parent_span_id\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "op":
			if err := func() error {
				s.Op.Reset()
				if err := s.Op.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"op\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "tags":
			if err := func() error {
				s.Tags.Reset()
				if err := s.Tags.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		case "start_timestamp":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.StartTimestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"start_timestamp\"")
			}
		case "timestamp":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Span")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000011,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSpan) {
					name = jsonFieldsNameOfSpan[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Span) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Span) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SpanData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s SpanData) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes SpanData from json.
func (s *SpanData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpanData to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SpanData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SpanData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpanData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SpanID as json.
func (s SpanID) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes SpanID from json.
func (s *SpanID) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpanID to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = SpanID(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SpanID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpanID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SpanTags) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s SpanTags) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes SpanTags from json.
func (s *SpanTags) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpanTags to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SpanTags")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SpanTags) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpanTags) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Stacktrace) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Stacktrace) encodeFields(e *jx.Encoder) {
	{
		if s.Frames != nil {
			e.FieldStart("frames")
			e.ArrStart()
			for _, elem := range s.Frames {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Registers.Set {
			e.FieldStart("registers")
			s.Registers.Encode(e)
		}
	}
}

var jsonFieldsNameOfStacktrace = [2]string{
	0: "frames",
	1: "registers",
}

// Decode decodes Stacktrace from json.
func (s *Stacktrace) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Stacktrace to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "frames":
			if err := func() error {
				s.Frames = make([]Frame, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Frame
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Frames = append(s.Frames, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"frames\"")
			}
		case "registers":
			if err := func() error {
				s.Registers.Reset()
				if err := s.Registers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"registers\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Stacktrace")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Stacktrace) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Stacktrace) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s StacktraceRegisters) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s StacktraceRegisters) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes StacktraceRegisters from json.
func (s *StacktraceRegisters) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StacktraceRegisters to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode StacktraceRegisters")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s StacktraceRegisters) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StacktraceRegisters) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Thread) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Thread) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.Crashed.Set {
			e.FieldStart("crashed")
			s.Crashed.Encode(e)
		}
	}
	{
		if s.Current.Set {
			e.FieldStart("current")
			s.Current.Encode(e)
		}
	}
	{
		if s.Main.Set {
			e.FieldStart("main")
			s.Main.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.State.Set {
			e.FieldStart("state")
			s.State.Encode(e)
		}
	}
	{
		if s.HeldLocks.Set {
			e.FieldStart("held_locks")
			s.HeldLocks.Encode(e)
		}
	}
}

var jsonFieldsNameOfThread = [7]string{
	0: "id",
	1: "crashed",
	2: "current",
	3: "main",
	4: "name",
	5: "state",
	6: "held_locks",
}

// Decode decodes Thread from json.
func (s *Thread) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Thread to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "crashed":
			if err := func() error {
				s.Crashed.Reset()
				if err := s.Crashed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"crashed\"")
			}
		case "current":
			if err := func() error {
				s.Current.Reset()
				if err := s.Current.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current\"")
			}
		case "main":
			if err := func() error {
				s.Main.Reset()
				if err := s.Main.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"main\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "state":
			if err := func() error {
				s.State.Reset()
				if err := s.State.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		case "held_locks":
			if err := func() error {
				s.HeldLocks.Reset()
				if err := s.HeldLocks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"held_locks\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Thread")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfThread) {
					name = jsonFieldsNameOfThread[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Thread) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Thread) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ThreadHeldLocks) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s ThreadHeldLocks) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes ThreadHeldLocks from json.
func (s *ThreadHeldLocks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ThreadHeldLocks to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ThreadHeldLocks")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ThreadHeldLocks) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ThreadHeldLocks) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Timestamp as json.
func (s Timestamp) Encode(e *jx.Encoder) {
	unwrapped := time.Time(s)

	json.EncodeDateTime(e, unwrapped)
}

// Decode decodes Timestamp from json.
func (s *Timestamp) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Timestamp to nil")
	}
	var unwrapped time.Time
	if err := func() error {
		v, err := json.DecodeDateTime(d)
		unwrapped = v
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = Timestamp(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Timestamp) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Timestamp) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TraceID as json.
func (s TraceID) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes TraceID from json.
func (s *TraceID) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TraceID to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TraceID(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TraceID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TraceID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TransactionInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TransactionInfo) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("source")
		s.Source.Encode(e)
	}
}

var jsonFieldsNameOfTransactionInfo = [1]string{
	0: "source",
}

// Decode decodes TransactionInfo from json.
func (s *TransactionInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TransactionInfo to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "source":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Source.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TransactionInfo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTransactionInfo) {
					name = jsonFieldsNameOfTransactionInfo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TransactionInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TransactionInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TransactionSource as json.
func (s TransactionSource) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes TransactionSource from json.
func (s *TransactionSource) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TransactionSource to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = TransactionSource(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TransactionSource) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TransactionSource) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *User) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *User) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Email.Set {
			e.FieldStart("email")
			s.Email.Encode(e)
		}
	}
	{
		if s.IPAddress.Set {
			e.FieldStart("ip_address")
			s.IPAddress.Encode(e)
		}
	}
	{
		if s.Username.Set {
			e.FieldStart("username")
			s.Username.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Segment.Set {
			e.FieldStart("segment")
			s.Segment.Encode(e)
		}
	}
	for k, elem := range s.AdditionalProps {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

var jsonFieldsNameOfUser = [6]string{
	0: "id",
	1: "email",
	2: "ip_address",
	3: "username",
	4: "name",
	5: "segment",
}

// Decode decodes User from json.
func (s *User) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode User to nil")
	}
	s.AdditionalProps = map[string]jx.Raw{}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "ip_address":
			if err := func() error {
				s.IPAddress.Reset()
				if err := s.IPAddress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ip_address\"")
			}
		case "username":
			if err := func() error {
				s.Username.Reset()
				if err := s.Username.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "segment":
			if err := func() error {
				s.Segment.Reset()
				if err := s.Segment.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"segment\"")
			}
		default:
			var elem jx.Raw
			if err := func() error {
				v, err := d.RawAppend(nil)
				elem = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			s.AdditionalProps[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode User")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *User) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *User) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s UserAdditional) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s UserAdditional) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes UserAdditional from json.
func (s *UserAdditional) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserAdditional to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserAdditional")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UserAdditional) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserAdditional) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
