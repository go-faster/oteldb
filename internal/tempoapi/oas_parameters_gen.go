// Code generated by ogen, DO NOT EDIT.

package tempoapi

import (
	"net/http"
	"net/url"
	"time"

	"github.com/go-faster/errors"
	"github.com/google/uuid"

	"github.com/ogen-go/ogen/conv"
	"github.com/ogen-go/ogen/middleware"
	"github.com/ogen-go/ogen/ogenerrors"
	"github.com/ogen-go/ogen/uri"
	"github.com/ogen-go/ogen/validate"
)

// SearchParams is parameters of search operation.
type SearchParams struct {
	// URL-encoded TraceQL query.
	Q OptString
	// Logfmt encoding of any span-level or process-level attributes to filter on.
	// The value is matched as a case-insensitive substring.
	// Key-value pairs are separated by spaces.
	// If a value contains a space, it should be enclosed within double quotes.
	Tags OptString
	// Find traces with at least this duration. Duration values are of the form 10s for 10 seconds, 100ms,
	//  30m, etc.
	MinDuration OptDuration
	// Find traces with no greater than this duration. Uses the same form as `minDuration`.
	MaxDuration OptDuration
	// Limit the number of search results. Default is 20, but this is configurable in the querier. Refer
	// to Configuration.
	Limit OptInt
	// Along with `end` define a time range from which traces should be returned.
	Start OptUnixSeconds
	// Along with `start`, define a time range from which traces should be returned.
	// Providing both `start` and `end` will change the way that Tempo searches.
	// If the parameters are not provided, then Tempo will search the recent trace data stored in the
	// ingesters.
	// If the parameters are provided, it will search the backend as well.
	End OptUnixSeconds
}

func unpackSearchParams(packed middleware.Parameters) (params SearchParams) {
	{
		key := middleware.ParameterKey{
			Name: "q",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Q = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "tags",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Tags = v.(OptString)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "minDuration",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.MinDuration = v.(OptDuration)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "maxDuration",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.MaxDuration = v.(OptDuration)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "limit",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Limit = v.(OptInt)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "start",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Start = v.(OptUnixSeconds)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "end",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.End = v.(OptUnixSeconds)
		}
	}
	return params
}

func decodeSearchParams(args [0]string, argsEscaped bool, r *http.Request) (params SearchParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: q.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "q",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotQVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotQVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Q.SetTo(paramsDotQVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "q",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: tags.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "tags",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotTagsVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotTagsVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Tags.SetTo(paramsDotTagsVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "tags",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: minDuration.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "minDuration",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotMinDurationVal time.Duration
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToDuration(val)
					if err != nil {
						return err
					}

					paramsDotMinDurationVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.MinDuration.SetTo(paramsDotMinDurationVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "minDuration",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: maxDuration.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "maxDuration",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotMaxDurationVal time.Duration
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToDuration(val)
					if err != nil {
						return err
					}

					paramsDotMaxDurationVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.MaxDuration.SetTo(paramsDotMaxDurationVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "maxDuration",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: limit.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "limit",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: start.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "start",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStartVal time.Time
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToUnixSeconds(val)
					if err != nil {
						return err
					}

					paramsDotStartVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Start.SetTo(paramsDotStartVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "start",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: end.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "end",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotEndVal time.Time
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToUnixSeconds(val)
					if err != nil {
						return err
					}

					paramsDotEndVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.End.SetTo(paramsDotEndVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "end",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// SearchTagValuesParams is parameters of search_tag_values operation.
type SearchTagValuesParams struct {
	// Tag name.
	TagName string
}

func unpackSearchTagValuesParams(packed middleware.Parameters) (params SearchTagValuesParams) {
	{
		key := middleware.ParameterKey{
			Name: "tag_name",
			In:   "path",
		}
		params.TagName = packed[key].(string)
	}
	return params
}

func decodeSearchTagValuesParams(args [1]string, argsEscaped bool, r *http.Request) (params SearchTagValuesParams, _ error) {
	// Decode path: tag_name.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "tag_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TagName = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "tag_name",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// SearchTagValuesV2Params is parameters of search_tag_values_v2 operation.
type SearchTagValuesV2Params struct {
	// Tag name.
	TagName string
}

func unpackSearchTagValuesV2Params(packed middleware.Parameters) (params SearchTagValuesV2Params) {
	{
		key := middleware.ParameterKey{
			Name: "tag_name",
			In:   "path",
		}
		params.TagName = packed[key].(string)
	}
	return params
}

func decodeSearchTagValuesV2Params(args [1]string, argsEscaped bool, r *http.Request) (params SearchTagValuesV2Params, _ error) {
	// Decode path: tag_name.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "tag_name",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.TagName = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "tag_name",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// TraceByIDParams is parameters of traceByID operation.
type TraceByIDParams struct {
	// TraceID to query.
	TraceID uuid.UUID
	// Along with `end` define a time range from which traces should be returned.
	Start OptUnixSeconds
	// Along with `start` define a time range from which traces should be returned.
	// Providing both `start` and `end` will include traces for the specified time range only.
	// If the parameters are not provided then Tempo will check for the trace across all blocks in
	// backend.
	// If the parameters are provided, it will only check in the blocks within the specified time range,
	// this can result in trace not being found or partial results if it does not fall in the specified
	// time range.
	End OptUnixSeconds
}

func unpackTraceByIDParams(packed middleware.Parameters) (params TraceByIDParams) {
	{
		key := middleware.ParameterKey{
			Name: "traceID",
			In:   "path",
		}
		params.TraceID = packed[key].(uuid.UUID)
	}
	{
		key := middleware.ParameterKey{
			Name: "start",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.Start = v.(OptUnixSeconds)
		}
	}
	{
		key := middleware.ParameterKey{
			Name: "end",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.End = v.(OptUnixSeconds)
		}
	}
	return params
}

func decodeTraceByIDParams(args [1]string, argsEscaped bool, r *http.Request) (params TraceByIDParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: traceID.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "traceID",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToUUID(val)
				if err != nil {
					return err
				}

				params.TraceID = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "traceID",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: start.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "start",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStartVal time.Time
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToUnixSeconds(val)
					if err != nil {
						return err
					}

					paramsDotStartVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Start.SetTo(paramsDotStartVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "start",
			In:   "query",
			Err:  err,
		}
	}
	// Decode query: end.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "end",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotEndVal time.Time
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToUnixSeconds(val)
					if err != nil {
						return err
					}

					paramsDotEndVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.End.SetTo(paramsDotEndVal)
				return nil
			}); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "end",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}
